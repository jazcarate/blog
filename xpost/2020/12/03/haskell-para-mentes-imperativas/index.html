<!DOCTYPE html>
<html lang="en">
<head>
    
    <!-- Global site tag (gtag.js) - Google Analytics -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-689SEV7MTT"></script>
    <script>window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date()); gtag('config', 'G-689SEV7MTT', { cookie_domain: 'blog.florius.com.ar', cookie_flags: 'SameSite=None;Secure' });</script>
    
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <title>Haskell para mentes imperativas &#8211; Florius‚Äô Blog</title>
    <link rel="dns-prefetch" href="//fonts.googleapis.com">
    <link rel="dns-prefetch" href="//fonts.gstatic.com">
    <link rel="dns-prefetch" href="//maxcdn.bootstrapcdn.com">
    <link rel="dns-prefetch" href="//cdnjs.cloudflare.com">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="En este post quiero explorar algunas cosas que creo que me hubiesen servido para aprender Haskell. Teniendo una base en alg√∫n lenguaje imperativo, usar esta para programar en Haskell.">
    <link rel="manifest" type="application/manifest+json; charset=utf-8" href="/site.webmanifest" />
    <meta name="robots" content="all">
    <meta name="author" content="">
    
    <meta name="keywords" content="xpost">
    <link rel="canonical" href="https://dev.to/florius/haskell-para-mentes-imperativas-4n7k">
    <link rel="alternate" type="application/rss+xml" title="RSS Feed for Florius‚Äô Blog" href="/feed.xml" />

    <!-- Custom CSS -->
    <link rel="stylesheet" href="/css/pixyll.css?202105011205" type="text/css">

    <!-- Fonts -->
    <link href="//fonts.googleapis.com/css?family=Karla|Montserrat&amp;display=swap" rel="stylesheet">
    
    <script src="//kit.fontawesome.com/88434a0a24.js" crossorigin="anonymous"></script>
    

    <!-- MathJax -->
    

    <!-- Verifications -->
    
    

    <!-- Open Graph -->
    <!-- From: https://github.com/mmistakes/hpstr-jekyll-theme/blob/master/_includes/head.html -->
    <meta property="og:locale" content="en_US">
    <meta property="og:type" content="article">
    <meta property="og:title" content="Haskell para mentes imperativas">
    <meta property="og:description" content="Joaquin &quot;Flroius&quot; Azcarate‚Äôs personal blog">
    <meta property="og:url" content="https://blog.florius.com.ar/xpost/2020/12/03/haskell-para-mentes-imperativas/">
    <meta property="og:site_name" content="Florius‚Äô Blog">

    <!-- Twitter Card -->
    <meta name="twitter:card" content="summary" />
    
    <meta name="twitter:title" content="Haskell para mentes imperativas" />
    <meta name="twitter:description" content="En este post quiero explorar algunas cosas que creo que me hubiesen servido para aprender Haskell. Teniendo una base en alg√∫n lenguaje imperativo, usar esta para programar en Haskell." />
    <meta name="twitter:url" content="https://blog.florius.com.ar/xpost/2020/12/03/haskell-para-mentes-imperativas/" />

    <!-- Icons -->
    <link rel="apple-touch-icon" sizes="180x180" href="">
    <link rel="icon" type="image/png" sizes="32x32" href="">
    <link rel="icon" type="image/png" sizes="16x16" href="">
    <link rel="manifest" href="">
    <link rel="shortcut icon" href="/favicon.ico">

    
</head>

<body class="site">
	

  <div class="site-wrap">
    <header class="site-header px2 px-responsive">
  <div class="mt2 wrap">
    <div class="measure">
      <a href="/" class="site-title">Florius‚Äô Blog</a>
      <nav class="site-nav">
        



    
    
    
    

    

    
    
    
    
        <a class="nav-link" href="/about/">About</a>
    

    

    
    
    
    
        <a class="nav-link" href="/categories/">Categories</a>
    

    

    
    
    
    

    

    
    
    
    

    

    
    
    
    

    

    
    
    
    

    

    
    
    
    

    

    
    
    
    

    

    
    
    
    

    

    
    
    
    

    

    
    
    
    

    


      </nav>
      <div class="clearfix"></div>
      
        <div class="social-icons">
  <div class="social-icons-right">
    
      <a class="fa fa-github" href="https://github.com/jazcarate"></a>
    
    
      <a class="fa fa-gitlab" href="https://gitlab.com/jazcarate"></a>
    
    
    
    
    
    
    
    
    
    
      <a class="fa fa-envelope" href="mailto:j@florius.com.ar"></a>
    
    
      <a class="fa fa-linkedin" href="https://www.linkedin.com/in/joaquin-azcarate"></a>
    
    
    <a class="fab fa-dev" href="https://dev.to/florius"></a>
    
    
    
    
    
  </div>
  <div class="right">
    
    
    
  </div>
</div>
<div class="clearfix"></div>

      
    </div>
  </div>
</header>


    <div class="post p2 p-responsive wrap animated fade-in-down" role="main">
      <div class="measure">
        


<div class="post-header mb2">
  <h1>Haskell para mentes imperativas</h1>
  <span class="post-meta">Dec 3, 2020</span><br>
  
  <span class="post-meta small read-time">
  
    13 minute read
  
  </span>
</div>

<article class="post-content">
  <p><em>El post original se puede leer en mi <a href="https://dev.to/florius/haskell-para-mentes-imperativas-4n7k">dev.to</a>.</em></p>

<p>Browseando YouTube encontr√© una playlist con un nombre muy interesante: ‚Äú<a href="https://www.youtube.com/watch?v=Vgu82wiiZ90&amp;list=PLe7Ei6viL6jGp1Rfu0dil1JH1SHk9bgDV">Haskell for Imperative Programmers</a>‚Äù en donde el autor Philipp Hagenlocher explica conceptos de Haskell en videos cortos, concisos, con varios ejemplos y hasta algunos ejercicios. Lo que me inspir√≥ a pensar c√≥mo podr√≠a aprender alguien que tiene ra√≠ces en un paradigma imperativo. Por suerte no tuve que usar mucho la imaginaci√≥n, ya que yo comenc√© con lenguajes imperativos, y en mi trabajo utilizo mayoritariamente el paradigma de objetos.</p>

<p>En este post quiero explorar algunas cosas que creo que me hubiesen servido para aprender Haskell. Teniendo una base en alg√∫n lenguaje imperativo, usar esta para programar en Haskell.</p>

<p>Si crees que entras en esta categor√≠a, contin√∫a leyendo.</p>

<h3 id="prefacio">Prefacio</h3>
<p>En este post har√© uso de analog√≠as y de patrones fuertemente asociados a la programaci√≥n imperativa, de tal forma que la carga para aclimatarse al nuevo paradigma sea la menor posible, pero no considero esta la mejora forma de programar de forma funcional. Mi razonamiento es que: usando nuestro conocimiento previo ayude a comenzar a escalar la pendiente que es aprender un paradigma nuevo, y que esto a su vez dispare nuevas e interesantes investigaciones.</p>

<h2 id="variables">Variables</h2>

<p>Veo muy com√∫nmente la cara de espanto cuando uno habla de un lenguaje, como Haskell, donde la inmutabilidad est√° por defecto. Prontamente surge la pregunta de ‚Äúc√≥mo puedo asignar una variable‚Äù o ‚Äúcomo puedo cambiar el valor de un contador‚Äù.
Recordemos que Haskell es un lenguaje de programaci√≥n <a href="https://es.wikipedia.org/wiki/Turing_completo">Turing completo</a>, as√≠ que no es que <em>no se pueda</em> hacer, solo que hay que reconocer  que hay diferentes formas de afrontar un problema.</p>

<p>En Haskell, el s√≠mbolo <code class="language-plaintext highlighter-rouge">=</code> no representa una asignaci√≥n, si no es m√°s pr√≥ximo a la idea matem√°tica del <code class="language-plaintext highlighter-rouge">=</code> donde lo leemos (e interpretamos) como que algo <strong>es</strong> otra cosa.</p>

<p>En un lenguaje imperativo <code class="language-plaintext highlighter-rouge">x = 3</code> lo leemos como ‚Äúasignamos el valor <code class="language-plaintext highlighter-rouge">3</code> a la variable <code class="language-plaintext highlighter-rouge">x</code>‚Äù, donde en un paradigma funcional, lo deber√≠amos interpretar como ‚Äú<code class="language-plaintext highlighter-rouge">x</code> <em>es</em> 3‚Äù. <code class="language-plaintext highlighter-rouge">x</code> no puede cambiar. <code class="language-plaintext highlighter-rouge">x</code> simplemente <em>es</em>.</p>

<p>Se que esta justificaci√≥n suele no quitar el pavor. Tras indagar m√°s a fondo, suelo descubrir que hay dos temas distintos (pero muy  sobrelapados en los lenguajes imperativos):</p>

<p>Ponerle nombre a algo ‚Äúintermedio‚Äù. Por ejemplo, si uno est√° escribiendo un m√©todo, y ve que hay una operaci√≥n que se repite dos veces, suele ser considerado una buena pr√°ctica extraer lo com√∫n a una ‚Äúvariable‚Äù y ponerle nombre. Por ejemplo, podr√≠amos empezar con un m√©todo:</p>

<figure class="highlight"><pre><code class="language-java" data-lang="java"><span class="nc">Int</span> <span class="nf">foo</span><span class="o">(</span><span class="nc">List</span><span class="o">&lt;</span><span class="nc">Int</span><span class="o">&gt;</span> <span class="n">xs</span><span class="o">)</span> <span class="o">{</span>
  <span class="k">if</span><span class="o">(</span><span class="n">xs</span><span class="o">.</span><span class="na">size</span><span class="o">()</span> <span class="o">&gt;</span> <span class="mi">3</span><span class="o">)</span>
    <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="o">;</span>
  <span class="k">else</span>
    <span class="k">return</span> <span class="n">xs</span><span class="o">.</span><span class="na">size</span><span class="o">();</span>
<span class="o">}</span></code></pre></figure>

<p>y luego refactorizar a algo como:</p>

<figure class="highlight"><pre><code class="language-java" data-lang="java"><span class="nc">Int</span> <span class="nf">foo</span><span class="o">(</span><span class="nc">List</span><span class="o">&lt;</span><span class="nc">Int</span><span class="o">&gt;</span> <span class="n">xs</span><span class="o">)</span> <span class="o">{</span>
  <span class="nc">Int</span> <span class="n">tama√±o</span> <span class="o">=</span> <span class="n">xs</span><span class="o">.</span><span class="na">size</span><span class="o">();</span>
  <span class="k">if</span><span class="o">(</span><span class="n">tama√±o</span> <span class="o">&gt;</span> <span class="mi">3</span><span class="o">)</span>
    <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="o">;</span>
  <span class="k">else</span>
    <span class="k">return</span> <span class="n">tama√±o</span><span class="o">;</span>
<span class="o">}</span></code></pre></figure>

<p>En este acaso <code class="language-plaintext highlighter-rouge">tama√±o</code> si bien es una ‚Äúvariable‚Äù, su intenci√≥n no es variar en el contexto de la funci√≥n. Es tan com√∫n y √∫til poder aseverar sobre qu√© cosas no cambian, que en otros lenguajes existe la idea que las ‚Äúvariables‚Äù puedan ser constantes (vaya ox√≠moron). Como <code class="language-plaintext highlighter-rouge">const</code> en JavaScript y PHP, <code class="language-plaintext highlighter-rouge">val</code>/<code class="language-plaintext highlighter-rouge">var</code>en Kotlin, variables en may√∫sculas en Python o <code class="language-plaintext highlighter-rouge">final</code> en Java.</p>

<p>Lectores atentos pueden reconocer un potencial problema en esta refactorizaci√≥n, en donde no podemos asegurar 100% que el m√©todo <code class="language-plaintext highlighter-rouge">List::size()</code> no cambia la lista, y que invocarlo 2 veces como en el c√≥digo de ‚Äúantes‚Äù podr√≠a no ser igual al c√≥digo de ‚Äúdespues‚Äù en donde solo se invoca una vez. Dado que conocemos la sem√°ntica de <code class="language-plaintext highlighter-rouge">List::size()</code>, podemos descansar que no va a alterar la lista; pero a veces, por la naturaleza de la mutabilidad, esto lleva a problemas. Toda una categor√≠a de problemas que simplemente no pueden ocurrir en un mundo inmutable üòâ.</p>

<p>Esto mismo podr√≠amos lograr en Haskell con palabras reservadas como <code class="language-plaintext highlighter-rouge">let ‚Ä¶ in</code> o <code class="language-plaintext highlighter-rouge">where</code>.</p>

<figure class="highlight"><pre><code class="language-haskell" data-lang="haskell"><span class="n">foo</span> <span class="o">::</span> <span class="p">[</span><span class="kt">Int</span><span class="p">]</span> <span class="o">-&gt;</span> <span class="kt">Int</span>
<span class="n">foo</span> <span class="n">xs</span> <span class="o">=</span> <span class="kr">if</span> <span class="n">length</span> <span class="n">xs</span> <span class="kr">then</span>
         <span class="o">-</span><span class="mi">1</span>
       <span class="kr">else</span>
         <span class="n">length</span> <span class="n">xs</span></code></pre></figure>

<p>Y luego del refactor:</p>

<figure class="highlight"><pre><code class="language-haskell" data-lang="haskell"><span class="n">foo</span> <span class="o">::</span> <span class="p">[</span><span class="kt">Int</span><span class="p">]</span> <span class="o">-&gt;</span> <span class="kt">Int</span>
<span class="n">foo</span> <span class="n">xs</span> <span class="o">=</span>
   <span class="kr">let</span> <span class="n">tama</span><span class="err">√±</span><span class="n">o</span> <span class="o">=</span> <span class="n">length</span> <span class="n">xs</span>
   <span class="kr">in</span> <span class="kr">if</span> <span class="n">tama</span><span class="err">√±</span><span class="n">o</span> <span class="o">&gt;</span> <span class="mi">3</span> <span class="kr">then</span>
         <span class="o">-</span><span class="mi">1</span>
       <span class="kr">else</span>
         <span class="n">tama</span><span class="err">√±</span><span class="n">o</span></code></pre></figure>

<p>o</p>

<figure class="highlight"><pre><code class="language-haskell" data-lang="haskell"><span class="n">foo</span> <span class="o">::</span> <span class="p">[</span><span class="kt">Int</span><span class="p">]</span> <span class="o">-&gt;</span> <span class="kt">Int</span>
<span class="n">foo</span> <span class="n">xs</span> <span class="o">=</span> <span class="kr">if</span> <span class="n">tama</span><span class="err">√±</span><span class="n">o</span> <span class="o">&gt;</span> <span class="mi">3</span> <span class="kr">then</span>
         <span class="o">-</span><span class="mi">1</span>
       <span class="kr">else</span>
         <span class="n">tama</span><span class="err">√±</span><span class="n">o</span>
   <span class="kr">where</span> <span class="n">tama</span><span class="err">√±</span><span class="n">o</span> <span class="o">=</span> <span class="n">length</span> <span class="n">xs</span></code></pre></figure>

<p>Si bien hacen lo mismo, tienen sutiles diferencias a las entrar√© en detalle (pero si est√° aqu√≠: <a href="https://wiki.haskell.org/Let_vs._Where">Let vs. Where - HaskellWiki</a>).</p>

<h2 id="cosas-que-cambian">Cosas que cambian</h2>

<p>El otro <em>sabor</em> de variables, es el de algo que cambia; y aqu√≠, no tenemos suerte. No vamos a poder hacerlo. Pero eso no quita que podamos generar abstracciones para poder escribir algo que <em>se parezca</em>.</p>

<p>Pero antes de hablar de cosas que cambian, primero necesitamos estar de acuerdo en algunas convenciones. Cosas como</p>

<figure class="highlight"><pre><code class="language-c" data-lang="c"><span class="kt">void</span> <span class="nf">bar</span><span class="p">(</span><span class="kt">int</span><span class="o">*</span> <span class="n">x</span><span class="p">){</span>
    <span class="o">*</span><span class="n">x</span> <span class="o">+=</span> <span class="mi">4</span><span class="p">;</span>
<span class="p">}</span></code></pre></figure>

<p>En donde una funci√≥n altera el valor que se le pasa son <em>el mal</em>, y no poder hacerlo es un <em>feature</em> (Aunque me encanta la idea de <a href="https://www.tweag.io/blog/2020-11-11-linear-dps/">Pure destination-passing style in Linear Haskell</a> cuando se apalanca del maravilloso sistema de tipos).</p>

<p>Algo mucho m√°s sensible ser√≠a una funci√≥n que tome el argumento y devuelva un nuevo n√∫mero, resultado de la suma del argumento y 4.</p>

<p>Pero no siempre es tan sencillo. A veces tenemos varias mutaciones encadenadas, o unas que dependen de otras; por lo que podemos aplicar este algoritmo mental:
Cada vez que fu√©semos a cambiar una variable, en realidad utilizaremos una nueva variable que sea el resultado del cambio, y de ahora en adelante, utilizar el nuevo nombre.</p>

<p>Por ejemplo, con la nueva herramienta de <code class="language-plaintext highlighter-rouge">let ‚Ä¶ in</code>:</p>

<figure class="highlight"><pre><code class="language-ruby" data-lang="ruby"><span class="k">def</span> <span class="nf">buzz</span> <span class="p">(</span><span class="n">n</span><span class="p">)</span>
  <span class="n">ret</span> <span class="o">=</span> <span class="n">n</span>
  <span class="n">ret</span> <span class="o">=</span> <span class="n">ret</span> <span class="o">%</span> <span class="mi">3</span>
  <span class="n">ret</span> <span class="o">=</span> <span class="n">ret</span> <span class="o">+</span><span class="mi">2</span>
  <span class="n">ret</span> <span class="o">=</span> <span class="n">ret</span> <span class="o">+</span> <span class="mi">5</span>
  <span class="n">ret</span> <span class="o">&gt;</span> <span class="mi">3</span>
<span class="k">end</span></code></pre></figure>

<figure class="highlight"><pre><code class="language-haskell" data-lang="haskell"><span class="n">buzz</span> <span class="n">n</span> <span class="o">=</span>
  <span class="kr">let</span> 
       <span class="n">x0</span> <span class="o">=</span> <span class="n">n</span>
       <span class="n">x1</span> <span class="o">=</span> <span class="n">x0</span> <span class="p">`</span><span class="n">mod</span><span class="p">`</span> <span class="mi">3</span>
       <span class="n">x2</span> <span class="o">=</span> <span class="n">x1</span> <span class="o">+</span> <span class="mi">2</span>
       <span class="n">x3</span> <span class="o">=</span> <span class="n">x2</span> <span class="o">+</span> <span class="mi">5</span>
  <span class="kt">In</span> <span class="n">x3</span> <span class="o">&gt;</span> <span class="mi">3</span></code></pre></figure>

<p>Si esta forma de escribir parece tediosa (lo es!), al final de la pr√≥xima secci√≥n volveremos sobre esto, pero todav√≠a tenemos algo que podemos hacer. Revisemos qu√© es lo que es tan inconveniente: nombrar los pasos intermedios (<code class="language-plaintext highlighter-rouge">x0 - x3</code>) ¬øPodemos no hacerlo?.</p>

<p>De esta forma nos acercamos a un patr√≥n muy com√∫n en funcional, en donde uno tiene funciones intermedias que toman un valor, y devuelven ‚Äúel nuevo‚Äù valor. Podemos concatenar estas operaciones (que hablan de cambios, no de variables).</p>

<p>Imaginemos el mismo ejemplo, pero vamos a re escribirlo en peque√±as funciones intermedias que cambien el valor.</p>

<figure class="highlight"><pre><code class="language-haskell" data-lang="haskell"><span class="n">buzz</span> <span class="n">n</span> <span class="o">=</span>
  <span class="kr">let</span> <span class="n">f0</span> <span class="n">x</span> <span class="o">=</span> <span class="n">x</span> <span class="p">`</span><span class="n">mod</span><span class="p">`</span> <span class="mi">3</span>
       <span class="n">f1</span> <span class="n">x</span> <span class="o">=</span> <span class="n">x</span> <span class="o">+</span> <span class="mi">2</span>
       <span class="n">f2</span> <span class="n">x</span> <span class="o">=</span> <span class="n">x</span> <span class="o">+</span> <span class="mi">5</span>
       <span class="n">f3</span> <span class="n">x</span> <span class="o">=</span> <span class="n">x</span> <span class="o">&gt;</span> <span class="mi">3</span>
      
       <span class="n">x0</span> <span class="o">=</span> <span class="n">n</span>
       <span class="n">x1</span> <span class="o">=</span> <span class="n">f0</span> <span class="n">x0</span>
       <span class="n">x2</span> <span class="o">=</span> <span class="n">f1</span> <span class="n">x1</span>
       <span class="n">x3</span> <span class="o">=</span> <span class="n">f2</span> <span class="n">x2</span>
  <span class="kt">In</span> <span class="n">f3</span> <span class="n">x3</span></code></pre></figure>

<p>Lamentablemente como es un ejemplo tan sint√©tico, los nombres de las funciones intermedias ser√°n malos; pero espero que puedan imaginarse que estas funciones sean cosas como <code class="language-plaintext highlighter-rouge">incrementarEdad</code>, <code class="language-plaintext highlighter-rouge">extraerDinero</code> u otro nombre m√°s cercano al dominio de lo que esten programando.</p>

<p>Por ello voy a cambiar levemente el ejemplo para tener algo que sea m√°s humanamente legible.</p>

<figure class="highlight"><pre><code class="language-haskell" data-lang="haskell"><span class="n">numeroValidador</span> <span class="n">x</span> <span class="o">=</span> <span class="n">x</span> <span class="p">`</span><span class="n">mod</span><span class="p">`</span> <span class="mi">3</span>
<span class="n">normalizarValidador</span> <span class="n">x</span> <span class="o">=</span> <span class="n">x</span> <span class="o">+</span> <span class="mi">2</span>
<span class="n">migrarCoeficiente</span> <span class="n">x</span> <span class="o">=</span> <span class="n">x</span> <span class="o">+</span> <span class="mi">5</span>
<span class="n">esValido</span> <span class="n">x</span> <span class="o">=</span> <span class="n">x</span> <span class="o">&gt;</span> <span class="mi">3</span>

<span class="n">tarjetaValida</span> <span class="n">n</span> <span class="o">=</span>
       <span class="n">x0</span> <span class="o">=</span> <span class="n">numeroValidador</span> <span class="n">n</span>
       <span class="n">x1</span> <span class="o">=</span> <span class="n">normalizarValidador</span> <span class="n">x0</span>
       <span class="n">x2</span> <span class="o">=</span> <span class="n">migrarCoeficiente</span> <span class="n">x1</span>
  <span class="kt">In</span> <span class="n">esValido</span> <span class="n">x2</span></code></pre></figure>

<p>Ahora podemos intentar pensar sobre nuestra <code class="language-plaintext highlighter-rouge">tarjetaValida</code>, donde lo que tiene que pasar es, en orden:</p>

<ol>
  <li>Dado un n√∫mero pasado como par√°metro (<code class="language-plaintext highlighter-rouge">n</code>)</li>
  <li>Tomamos el n√∫mero validador (<code class="language-plaintext highlighter-rouge">x mod 3</code>)</li>
  <li>Lo normalizamos (<code class="language-plaintext highlighter-rouge">x + 2</code>)</li>
  <li>Migramos el coeficiente (<code class="language-plaintext highlighter-rouge">x + 5</code>)</li>
  <li>Y chequeamos que sea v√°lido (<code class="language-plaintext highlighter-rouge">x &gt; 3</code>)</li>
</ol>

<p>Probablemente todav√≠a no sea evidente, pero ahora podemos hacer un refactor de ‚Äúinline‚Äù en cada variable intermedia (<code class="language-plaintext highlighter-rouge">x0 - x3</code>). Empecemos con <code class="language-plaintext highlighter-rouge">x3</code> e iremos ineline-ando de a una</p>

<figure class="highlight"><pre><code class="language-haskell" data-lang="haskell"><span class="n">tarjetaValida</span> <span class="n">n</span> <span class="o">=</span>
       <span class="n">x0</span> <span class="o">=</span> <span class="n">n</span>
       <span class="n">x1</span> <span class="o">=</span> <span class="n">numeroValidador</span> <span class="n">x0</span>
       <span class="n">x2</span> <span class="o">=</span> <span class="n">normalizarValidador</span> <span class="n">x1</span>
  <span class="kt">In</span> <span class="n">esValido</span> <span class="p">(</span><span class="n">migrarCoeficiente</span>  <span class="n">x1</span><span class="p">)</span></code></pre></figure>

<figure class="highlight"><pre><code class="language-haskell" data-lang="haskell"><span class="n">tarjetaValida</span> <span class="n">n</span> <span class="o">=</span>
       <span class="n">x0</span> <span class="o">=</span> <span class="n">n</span>
       <span class="n">x1</span> <span class="o">=</span> <span class="n">numeroValidador</span> <span class="n">x0</span>
  <span class="kt">In</span> <span class="n">esValido</span> <span class="p">(</span><span class="n">migrarCoeficiente</span>  <span class="p">(</span><span class="n">normalizarValidador</span>  <span class="n">x1</span><span class="p">))</span></code></pre></figure>

<figure class="highlight"><pre><code class="language-haskell" data-lang="haskell"><span class="n">tarjetaValida</span> <span class="n">n</span> <span class="o">=</span>
       <span class="n">x0</span> <span class="o">=</span> <span class="n">n</span>
  <span class="n">esValido</span>  <span class="p">(</span><span class="n">migrarCoeficiente</span> <span class="p">(</span><span class="n">normalizarValidador</span> <span class="p">(</span><span class="n">numeroValidador</span> <span class="n">x0</span><span class="p">)))</span></code></pre></figure>

<figure class="highlight"><pre><code class="language-haskell" data-lang="haskell"><span class="n">tarjetaValida</span> <span class="n">n</span> <span class="o">=</span>
  <span class="n">esValido</span>  <span class="p">(</span><span class="n">migrarCoeficiente</span> <span class="p">(</span><span class="n">normalizarValidador</span> <span class="p">(</span><span class="n">numeroValidador</span> <span class="n">n</span><span class="p">)))</span></code></pre></figure>

<p>Esto se parece mucho m√°s a la descripci√≥n funcional de <code class="language-plaintext highlighter-rouge">tarjetaValida</code>, pero est√° escrito ‚Äúal rev√©s‚Äù. Por razones como esta existen <a href="https://hackage.haskell.org/package/base-4.14.0.0/docs/Data-Function.html#v:-38-">combinadores como <code class="language-plaintext highlighter-rouge">&amp;</code></a>, donde hablando mal y pronto, √©ste es el operador de <em>aplicaci√≥n reversa</em>.</p>

<figure class="highlight"><pre><code class="language-haskell" data-lang="haskell"><span class="n">tarjetaValida</span> <span class="n">n</span> <span class="o">=</span>
  <span class="n">n</span> <span class="o">&amp;</span>
  <span class="n">numeroValidador</span> <span class="o">&amp;</span>
  <span class="n">normalizarValidador</span> <span class="o">&amp;</span>
  <span class="n">migrarCoeficiente</span> <span class="o">&amp;</span>
  <span class="n">esValido</span></code></pre></figure>

<p>Es interesante notar como todas nuestras funciones de ‚Äúcambio‚Äù tienen la misma firma: <code class="language-plaintext highlighter-rouge">:: Int -&gt; Int</code>. De forma m√°s gen√©rica, son funciones que toman un valor de un tipo, y <em>devuelven</em> algo del mismo tipo.</p>

<h3 id="aplicaci√≥n-parcial">Aplicaci√≥n parcial</h3>
<p>Con el c√≥digo que tenemos hasta aqu√≠; podr√≠amos cambiarlo para que <code class="language-plaintext highlighter-rouge">migrarCoeficiente</code> no siempre sume 5, si no que pueda ser parametrizable por una letra.
Sabiendo que hay una funci√≥n que transforma una letra a un n√∫mero <a href="https://hackage.haskell.org/package/base-4.14.0.0/docs/Data-Char.html#v:ord"><code class="language-plaintext highlighter-rouge">ord :: Char -&gt; Int</code></a> 
Podr√≠amos cambiar <code class="language-plaintext highlighter-rouge">migrarCoeficiente</code> a:</p>

<figure class="highlight"><pre><code class="language-haskell" data-lang="haskell"><span class="n">migrarCoeficiente</span> <span class="o">::</span> <span class="kt">Char</span> <span class="o">-&gt;</span> <span class="kt">Int</span> <span class="o">-&gt;</span> <span class="kt">Int</span>
<span class="n">migrarCoeficiente</span> <span class="n">letra</span> <span class="n">x</span> <span class="o">=</span> <span class="n">x</span> <span class="o">+</span> <span class="p">(</span><span class="n">ord</span> <span class="n">caracter</span><span class="p">)</span></code></pre></figure>

<p>Ahora nuestra <code class="language-plaintext highlighter-rouge">tarjetaValida</code> no sufre muchos cambios:</p>

<figure class="highlight"><pre><code class="language-haskell" data-lang="haskell"><span class="n">tarjetaValida</span> <span class="n">n</span> <span class="o">=</span>
  <span class="n">n</span> <span class="o">&amp;</span>
  <span class="n">numeroValidador</span> <span class="o">&amp;</span>
  <span class="n">normalizarValidador</span> <span class="o">&amp;</span>
  <span class="n">migrarCoeficiente</span> <span class="sc">'f'</span> <span class="o">&amp;</span>
  <span class="n">esValido</span></code></pre></figure>

<p>Y eso fu√© gracias a <a href="http://aprendehaskell.es/content/OrdenSuperior.html">la currificaci√≥n</a> de todas las funciones en Haskell!</p>

<h3 id="a-veces">A veces</h3>

<p>Otro gran ‚Äúhack‚Äù que nos permite la mutabilidad, es la de cambiar el valor, pero solo seg√∫n un flujo de control. Algo como:</p>

<figure class="highlight"><pre><code class="language-python" data-lang="python"><span class="k">def</span> <span class="nf">qux</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
  <span class="n">ret</span> <span class="o">=</span> <span class="n">n</span>
  <span class="k">if</span><span class="p">(</span><span class="n">ret</span> <span class="o">%</span> <span class="mi">3</span><span class="p">):</span>
    <span class="n">ret</span> <span class="o">=</span> <span class="mi">10</span>
  <span class="k">return</span> <span class="n">ret</span></code></pre></figure>

<p>En donde asignamos una variable que seg√∫n uno u otro flujo de control puede cambiar. Siempre podremos reescribir esto de forma inmutable. Por ejemplo</p>

<figure class="highlight"><pre><code class="language-haskell" data-lang="haskell"><span class="n">qux</span> <span class="n">n</span> <span class="o">=</span> <span class="kr">if</span> <span class="n">n</span> <span class="p">`</span><span class="n">mod</span><span class="p">`</span> <span class="mi">3</span> <span class="o">==</span> <span class="mi">0</span> <span class="kr">then</span> <span class="mi">10</span> <span class="kr">else</span> <span class="n">n</span></code></pre></figure>

<p>Interesante notar que necesitamos un <code class="language-plaintext highlighter-rouge">else</code> que ‚Äúdeje todo como estaba‚Äù, pues no podemos ‚Äúno hacer nada‚Äù en esta forma de escribirlo.</p>

<h2 id="monadas">Monadas</h2>

<p><em>(No pod√≠a ser un post de Haskell, y no mencionar a las monadas)</em></p>

<p>Una idea en la programaci√≥n imperativa muy arraigada es que uno escribe una l√≠nea debajo de la otra, y esto hace que se ejecuten en ese orden.
Tan arraigada que casi no se considera una decisi√≥n del lenguaje, pero lo es! Es una decisi√≥n de dise√±o, y una que en un paradigma funcional es f√°cil escaparse.</p>

<p>Pero a veces, queremos ordenar una secuencia de cosas. Recordemos el ejemplo anterior de <code class="language-plaintext highlighter-rouge">buz</code>. Hay una monada (y probablemente <a href="http://aprendehaskell.es/content/MasMonadas.html">miles de</a> <a href="https://gist.github.com/sdiehl/8d991a718f7a9c80f54b">tutoriales de</a> <a href="https://wiki.haskell.org/State_Monad">como</a> <a href="https://mmhaskell.com/monads/state">implementarla</a>) llamada ‚Äústate‚Äù que representa una forma de secuenciar operaciones, e ir mutando un valor. Por lo que uno podr√≠a escribir algo mucho m√°s parecido a la forma imperativa:</p>

<figure class="highlight"><pre><code class="language-haskell" data-lang="haskell"><span class="cd">--            |----- Va a ir mutando un Int
</span>
<span class="c1">--            v   v- va a retornar un booleano
</span>
<span class="n">buz</span> <span class="o">::</span> <span class="kt">State</span> <span class="kt">Int</span> <span class="kt">Bool</span>
<span class="n">buz</span> <span class="o">=</span>
  <span class="n">get</span> <span class="o">&gt;&gt;=</span> <span class="p">(</span><span class="nf">\</span><span class="n">ret</span> <span class="o">-&gt;</span> <span class="n">set</span> <span class="p">(</span><span class="n">ret</span> <span class="p">`</span><span class="n">mod</span><span class="p">`</span> <span class="mi">3</span><span class="p">))</span> <span class="o">&gt;&gt;</span>
  <span class="n">get</span> <span class="o">&gt;&gt;=</span> <span class="p">(</span><span class="nf">\</span><span class="n">ret</span> <span class="o">-&gt;</span> <span class="n">put</span> <span class="p">(</span><span class="n">ret</span> <span class="o">+</span> <span class="mi">2</span><span class="p">))</span> <span class="o">&gt;&gt;</span>
  <span class="n">get</span> <span class="o">&gt;&gt;=</span> <span class="p">(</span><span class="nf">\</span><span class="n">ret</span> <span class="o">-&gt;</span> <span class="n">set</span> <span class="p">(</span><span class="n">ret</span> <span class="o">+</span> <span class="mi">5</span><span class="p">))</span> <span class="o">&gt;&gt;</span>
  <span class="n">get</span> <span class="o">&gt;&gt;=</span> <span class="p">(</span><span class="nf">\</span><span class="n">ret</span> <span class="o">-&gt;</span> <span class="n">return</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&gt;</span> <span class="mi">3</span><span class="p">))</span></code></pre></figure>

<p>Cada <code class="language-plaintext highlighter-rouge">ret</code> en este caso solo existe dentro del lambda <em>(todo lo que est√© entre <code class="language-plaintext highlighter-rouge">(\</code> y <code class="language-plaintext highlighter-rouge">)</code>)</em></p>

<p>Muchas veces se ven las monadas con el <a href="https://es.wikipedia.org/wiki/Az%C3%BAcar_sint%C3%A1ctico"><em>az√∫car sint√°ctico</em></a> de la notaci√≥n <code class="language-plaintext highlighter-rouge">do</code>, que lo hace muy conveniente porque nos deja, como en un paradigma imperativo, escribir una l√≠nea debajo de la otra.</p>

<h3 id="monadas-cont">Monadas Cont.</h3>
<p>Otra gran raz√≥n para implementar una secuencia de operaciones, es que estas puedan fallar. El fallo en cualquier rengl√≥n invalide toda la computaci√≥n. Pensemos en m√©todos que podr√≠an lanzar excepciones.
Para esto tambi√©n existe una monada! Y podr√≠amos escribir algo como:</p>

<figure class="highlight"><pre><code class="language-swift" data-lang="swift"><span class="kd">func</span> <span class="nf">precio</span><span class="p">(</span><span class="n">itemConNombre</span> <span class="nv">nombre</span><span class="p">:</span> <span class="kt">String</span><span class="p">)</span> <span class="k">throws</span> <span class="p">{</span>
        <span class="k">guard</span> <span class="k">let</span> <span class="nv">item</span> <span class="o">=</span> <span class="n">inventario</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="k">else</span> <span class="p">{</span>
            <span class="k">throw</span> <span class="kt">Errores</span><span class="o">.</span><span class="nf">noExiste</span><span class="p">(</span><span class="nv">nombre</span><span class="p">:</span> <span class="n">nombre</span><span class="p">)</span>
        <span class="p">}</span>

        <span class="k">guard</span> <span class="n">item</span><span class="o">.</span><span class="n">cantidad</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="k">else</span> <span class="p">{</span>
            <span class="k">throw</span> <span class="kt">Errores</span><span class="o">.</span><span class="n">fueraDeStock</span>
        <span class="p">}</span>

        <span class="n">item</span><span class="o">.</span><span class="n">price</span>
<span class="p">}</span></code></pre></figure>

<p>De esta forma</p>

<figure class="highlight"><pre><code class="language-haskell" data-lang="haskell"><span class="kr">data</span> <span class="kt">Errores</span> <span class="o">=</span> <span class="kt">FueraDeStock</span> <span class="o">|</span> <span class="kt">NoExiste</span> <span class="kt">String</span>

<span class="n">buscar</span> <span class="o">::</span> <span class="kt">Inventario</span> <span class="o">-&gt;</span> <span class="kt">String</span> <span class="o">-&gt;</span> <span class="kt">Maybe</span> <span class="kt">Item</span>
<span class="n">buscar</span> <span class="o">=</span> <span class="p">(</span><span class="o">...</span><span class="p">)</span>

<span class="n">precio</span> <span class="o">::</span> <span class="kt">String</span> <span class="o">-&gt;</span> <span class="kt">Either</span> <span class="kt">Errores</span> <span class="kt">Int</span>
<span class="n">precio</span> <span class="n">nombre</span> <span class="o">=</span> <span class="kr">do</span>
    <span class="n">item</span> <span class="o">&lt;-</span> <span class="n">maybe</span> <span class="p">(</span><span class="kt">Left</span> <span class="p">(</span><span class="kt">NoExiste</span> <span class="n">nombre</span><span class="p">))</span> <span class="kt">Right</span> <span class="n">itemEncontrado</span> <span class="c1">-- (1)
</span>
    <span class="n">when</span> <span class="p">(</span><span class="n">cantidad</span> <span class="n">item</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">(</span><span class="kt">Left</span> <span class="kt">FueraDeStock</span><span class="p">)</span>
    <span class="n">return</span> <span class="n">precio</span> <span class="n">item</span>
  <span class="kr">where</span>
    <span class="n">itemEncontrado</span> <span class="o">::</span> <span class="kt">Maybe</span> <span class="kt">Item</span>
    <span class="n">itemEncontrado</span> <span class="o">=</span> <span class="n">buscar</span> <span class="n">inventario</span> <span class="n">nombre</span></code></pre></figure>

<p>La idea de la funci√≥n <a href="https://hackage.haskell.org/package/base-4.14.0.0/docs/Prelude.html#v:maybe"><code class="language-plaintext highlighter-rouge">maybe</code></a> es poder extraer el valor de un <code class="language-plaintext highlighter-rouge">Maybe</code> (algo que puede o no estar). En el caso de que pueda fallar, <em>devolveremos</em> un <code class="language-plaintext highlighter-rouge">Left</code> (recordemos, representar√≠a como lanzar una excepci√≥n), y en el caso que hubiese un <code class="language-plaintext highlighter-rouge">Item</code>, devolveremos un <code class="language-plaintext highlighter-rouge">Right</code>.</p>

<p>De esta forma, no <em>ejecutaremos</em> el <code class="language-plaintext highlighter-rouge">return</code> hasta que no pasen las dos condiciones anteriores.</p>

<h2 id="getter-y-setter">Getter y Setter</h2>

<p>Por √∫ltimo, quiero tocar algo de modelado, y la parte de lo que menos quiero escribir, porque es la que m√°s se separa del paradigma; pero no obstante puedo ver c√≥mo alguien puede estar tentado a utilizar herramientas de modelado de paradigmas que ya conoce, y pensar en un <a href="http://aprendehaskell.es/content/ClasesDeTipos.html"><em>record</em></a> es parecido a un objeto. Pero si as√≠ fuera‚Ä¶ donde ponemos los m√©todos de este objeto?! (Sin entrar en el mundo de <a href="https://hackage.haskell.org/package/lens"><code class="language-plaintext highlighter-rouge">lens</code></a>).
No voy a objetar (ü§≠) porque se que yo lo hice durante mucho tiempo, as√≠ que mientras que sepamos que hay <em>tela para cortar</em>, por ahora puedo vivir con que pensemos que son objetos.</p>

<figure class="highlight"><pre><code class="language-csharp" data-lang="csharp"><span class="k">class</span> <span class="nc">Point</span>
<span class="p">{</span>
    <span class="k">public</span> <span class="kt">int</span> <span class="n">edad</span><span class="p">;</span>
<span class="p">}</span></code></pre></figure>

<p>podr√≠amos escribirlo as√≠:</p>

<figure class="highlight"><pre><code class="language-haskell" data-lang="haskell"><span class="kr">data</span> <span class="kt">Persona</span> <span class="o">=</span> <span class="kt">Persona</span> <span class="p">{</span> <span class="n">edad</span> <span class="o">::</span> <span class="kt">Int</span> <span class="p">}</span></code></pre></figure>

<p>Y tendremos <em>gratis</em> la funci√≥n <code class="language-plaintext highlighter-rouge">edad :: Persona -&gt; Int</code> que ‚Äúsaca‚Äù la edad de una persona. Cual un getter, y la construcci√≥n:</p>

<figure class="highlight"><pre><code class="language-haskell" data-lang="haskell"><span class="n">cambiarEdad</span> <span class="o">::</span> <span class="kt">Int</span> <span class="o">-&gt;</span> <span class="kt">Persona</span> <span class="o">-&gt;</span> <span class="kt">Persona</span>
<span class="n">cambiarEdad</span> <span class="n">nuevaEdad</span> <span class="n">persona</span> <span class="o">=</span> <span class="n">persona</span> <span class="p">{</span> <span class="n">edad</span> <span class="o">=</span> <span class="n">nuevaEdad</span> <span class="p">}</span></code></pre></figure>

<p>Como un setter. Pero, como en OOP no estamos limitados a simplemente asignar el nuevo valor; podr√≠amos hacer lo que queramos!</p>

<figure class="highlight"><pre><code class="language-haskell" data-lang="haskell"><span class="n">cambiarEdad</span> <span class="o">::</span> <span class="kt">Int</span> <span class="o">-&gt;</span> <span class="kt">Persona</span> <span class="o">-&gt;</span> <span class="kt">Persona</span>
<span class="n">cambiarEdad</span> <span class="n">nuevaEdad</span> <span class="n">persona</span> <span class="o">=</span> <span class="n">persona</span> <span class="p">{</span> <span class="n">edad</span> <span class="o">=</span> <span class="n">nuevaEdad</span> <span class="o">+</span> <span class="mi">3</span> <span class="p">}</span></code></pre></figure>

<p>Podemos encontrar un patr√≥n recurrente, donde tengamos funciones que <em>terminen</em> con el tipo: <code class="language-plaintext highlighter-rouge">foo :: ‚Ä¶ -&gt; Algo -&gt; Algo</code>. Si recordamos el ejemplo de <code class="language-plaintext highlighter-rouge">tarjetaValida</code>, todas las funciones intermedias que ten√≠amos eran del tipo: <code class="language-plaintext highlighter-rouge">:: Int -&gt; Int</code>, y el ejercicio al lector hubiera generado una funci√≥n con el tipo: <code class="language-plaintext highlighter-rouge">:: Char -&gt; Int -&gt; Int</code>. Podemos pensar en toda esta familia de funciones como funciones que ‚Äúalteran‚Äù. Adem√°s ahora ya sabemos c√≥mo combinarlas!
Por ejemplo, concatenar listas  <a href="https://hackage.haskell.org/package/base-4.14.0.0/docs/GHC-List.html#v:-43--43-"><code class="language-plaintext highlighter-rouge">(++) :: [a] -&gt; [a] -&gt; [a] </code></a> en donde toma una primera lista y una segunda, y las ‚Äúaltera‚Äù (recordando que en realidad lo que hace es <em>devolver</em> una nueva lista) o tomar los primeros <code class="language-plaintext highlighter-rouge">n</code> elementos (<a href="https://hackage.haskell.org/package/base-4.14.0.0/docs/GHC-List.html#v:take"><code class="language-plaintext highlighter-rouge">take :: Int -&gt; [a] -&gt; [a]</code></a>). Hay much√≠simas funciones como estas, y probablemente escribamos tantas de estas como ‚Äúm√©todos‚Äù podr√≠an tener nuestros objetos, si lo modelamos en OOP.</p>

<figure class="highlight"><pre><code class="language-kotlin" data-lang="kotlin"><span class="kd">class</span> <span class="nc">Persona</span><span class="p">(</span><span class="kd">var</span> <span class="py">edad</span><span class="p">:</span> <span class="nc">Int</span><span class="p">,</span> <span class="kd">var</span> <span class="py">altura</span><span class="p">:</span> <span class="nc">Int</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">fun</span> <span class="nf">crecer</span><span class="p">(</span><span class="n">a√±os</span> <span class="p">:</span> <span class="nc">Int</span><span class="p">)</span> <span class="p">{</span>
                 <span class="k">this</span><span class="p">.</span><span class="n">edad</span> <span class="p">+=</span> <span class="n">a√±os</span>
                 <span class="k">this</span><span class="p">.</span><span class="n">altura</span> <span class="p">+=</span> <span class="n">a√±os</span><span class="p">*</span><span class="mi">2</span>
    <span class="p">}</span>
<span class="p">}</span></code></pre></figure>

<figure class="highlight"><pre><code class="language-haskell" data-lang="haskell"><span class="kr">data</span> <span class="kt">Persona</span> <span class="o">=</span> <span class="kt">Persona</span> <span class="p">{</span> <span class="n">edad</span> <span class="o">::</span> <span class="kt">Int</span><span class="p">,</span> <span class="n">altura</span> <span class="o">::</span> <span class="kt">Int</span> <span class="p">}</span>

<span class="n">crecer</span> <span class="o">::</span> <span class="kt">Int</span> <span class="o">-&gt;</span> <span class="kt">Persona</span> <span class="o">-&gt;</span> <span class="kt">Persona</span>
<span class="n">crecer</span> <span class="n">a</span><span class="err">√±</span><span class="n">os</span> <span class="n">persona</span> <span class="o">=</span> <span class="kt">Persona</span> <span class="p">{</span> <span class="n">edad</span> <span class="o">=</span> <span class="n">edad</span> <span class="n">persona</span> <span class="o">+</span> <span class="n">a</span><span class="err">√±</span><span class="n">os</span><span class="p">,</span>  <span class="n">altura</span> <span class="o">=</span> <span class="n">altura</span> <span class="n">persona</span> <span class="o">+</span> <span class="p">(</span><span class="n">a</span><span class="err">√±</span><span class="n">os</span> <span class="o">*</span> <span class="mi">2</span><span class="p">)</span> <span class="p">}</span></code></pre></figure>

<h2 id="fin">Fin</h2>
<p>Espero que con estas herramientas, el prospecto de programar en Haskell sea menos aterrorizador.</p>

</article>







<div class="separator">
  <img src="/assets/cat-0fe72554239fb5bc68cc3b08063d5fb3d3984c6381e560b01fa8d5e35ed5a68e4741595a4929859029f18386c321ac391d55cccf60a51f08dd3148d38b5a44b7.png">
</div>


  <h3 class="related-post-title">Related Posts</h3>
  
  
  
    
    

    

    

  
    
    

    

    
      
      <div class="post ml2 related">
        <a href="/xpost/2021/01/31/inspiraciones/" class="post-link">
          <h4 class="post-title">Inspiraciones</h4>
        </a>
        <p class="post-summary">
          ¬øTe pasa de querer programar algo y no saber que? tengo un bloqueo de ideas hace tiempo, quiero hacer algo con xxx y no se me ocurre qu√© hacer.
          <span class="related-categories">
            <a href="/categories#xpost">#xpost</a>
          </span>
        </p>
      </div>
      
      
    

  
    
    

    

    

  
    
    

    

    
      
      <div class="post ml2 related">
        <a href="/xpost/2020/09/14/koncierge-una-libreria-para-segmentar-usuarios/" class="post-link">
          <h4 class="post-title">koncierge Una librer√≠a para segmentar usuarios</h4>
        </a>
        <p class="post-summary">
          La historia de una librer√≠a para evaluar variantes de tests AB, dado una definici√≥n de un experimento con un DSL parecido a Mongo y un contexto.
          <span class="related-categories">
            <a href="/categories#xpost">#xpost</a>
          </span>
        </p>
      </div>
      
      
    

  
    
    

    

    
      
      <div class="post ml2 related">
        <a href="/xpost/2019/07/10/the-essence-of-event-sourcing/" class="post-link">
          <h4 class="post-title">The essence of Event Sourcing</h4>
        </a>
        <p class="post-summary">
          Event Sourcing is a somewhat trending topic, and you can find a lot of blog posts on what event sourcing supposedly is. I‚Äôll throw my wrench in the works and try to explain what I see as ‚ÄúEvent Sourcing‚Äù.
          <span class="related-categories">
            <a href="/categories#xpost">#xpost</a>
          </span>
        </p>
      </div>
      
      
        
  



      </div>
    </div>
  </div>

  <footer class="center">
  <div class="measure">
    <small>
      Theme heavily inspired in <a href="http://johnotander.com">John Otander</a>' <a href="https://github.com/johno/pixyll">pixyll</a>.
    </small>
  </div>
</footer>
<!-- AnchorJS -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/anchor-js/4.2.0/anchor.min.js"></script>
<script>
    anchors.options.visible = 'touch';
    anchors.add('article h2, article h3, article h4, article h5, article h6');
</script>

</body>
</html>
