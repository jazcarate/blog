<!DOCTYPE html>
<html lang="en">
<head>
    
    <!-- Global site tag (gtag.js) - Google Analytics -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-689SEV7MTT"></script>
    <script>window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date()); gtag('config', 'G-689SEV7MTT', { cookie_domain: 'blog.florius.com.ar', cookie_flags: 'SameSite=None;Secure' });</script>
    
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <title>Haskell para mentes imperativas &#8211; Florius’ Blog</title>
    <link rel="dns-prefetch" href="//fonts.googleapis.com">
    <link rel="dns-prefetch" href="//fonts.gstatic.com">
    <link rel="dns-prefetch" href="//maxcdn.bootstrapcdn.com">
    <link rel="dns-prefetch" href="//cdnjs.cloudflare.com">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="En este post quiero explorar algunas cosas que creo que me hubiesen servido para aprender Haskell. Teniendo una base en algún lenguaje imperativo, usar esta para programar en Haskell.">
    <link rel="manifest" type="application/manifest+json; charset=utf-8" href="/site.webmanifest" />
    <meta name="robots" content="all">
    <meta name="author" content="">
    
    <meta name="keywords" content="xpost">
    <link rel="canonical" href="https://dev.to/florius/haskell-para-mentes-imperativas-4n7k">
    <link rel="alternate" type="application/rss+xml" title="RSS Feed for Florius’ Blog" href="/feed.xml" />

    <!-- Custom CSS -->
    <link rel="stylesheet" href="/css/pixyll.css?202105011205" type="text/css">

    <!-- Fonts -->
    <link href="//fonts.googleapis.com/css?family=Karla|Montserrat&amp;display=swap" rel="stylesheet">
    
    <script src="//kit.fontawesome.com/88434a0a24.js" crossorigin="anonymous"></script>
    

    <!-- MathJax -->
    

    <!-- Verifications -->
    
    

    <!-- Open Graph -->
    <!-- From: https://github.com/mmistakes/hpstr-jekyll-theme/blob/master/_includes/head.html -->
    <meta property="og:locale" content="en_US">
    <meta property="og:type" content="article">
    <meta property="og:title" content="Haskell para mentes imperativas">
    <meta property="og:description" content="Joaquin &quot;Flroius&quot; Azcarate’s personal blog">
    <meta property="og:url" content="https://blog.florius.com.ar/xpost/2020/12/03/haskell-para-mentes-imperativas/">
    <meta property="og:site_name" content="Florius’ Blog">

    <!-- Twitter Card -->
    <meta name="twitter:card" content="summary" />
    
    <meta name="twitter:title" content="Haskell para mentes imperativas" />
    <meta name="twitter:description" content="En este post quiero explorar algunas cosas que creo que me hubiesen servido para aprender Haskell. Teniendo una base en algún lenguaje imperativo, usar esta para programar en Haskell." />
    <meta name="twitter:url" content="https://blog.florius.com.ar/xpost/2020/12/03/haskell-para-mentes-imperativas/" />

    <!-- Icons -->
    <link rel="apple-touch-icon" sizes="180x180" href="">
    <link rel="icon" type="image/png" sizes="32x32" href="">
    <link rel="icon" type="image/png" sizes="16x16" href="">
    <link rel="manifest" href="">
    <link rel="shortcut icon" href="/favicon.ico">

    
</head>

<body class="site">
	

  <div class="site-wrap">
    <header class="site-header px2 px-responsive">
  <div class="mt2 wrap">
    <div class="measure">
      <a href="/" class="site-title">Florius’ Blog</a>
      <nav class="site-nav">
        



    
    
    
    

    

    
    
    
    
        <a class="nav-link" href="/about/">About</a>
    

    

    
    
    
    
        <a class="nav-link" href="/categories/">Categories</a>
    

    

    
    
    
    

    

    
    
    
    

    

    
    
    
    

    

    
    
    
    

    

    
    
    
    

    

    
    
    
    

    

    
    
    
    

    

    
    
    
    

    

    
    
    
    

    


      </nav>
      <div class="clearfix"></div>
      
        <div class="social-icons">
  <div class="social-icons-right">
    
      <a class="fa fa-github" href="https://github.com/jazcarate"></a>
    
    
      <a class="fa fa-gitlab" href="https://gitlab.com/jazcarate"></a>
    
    
    
    
    
    
    
    
    
    
      <a class="fa fa-envelope" href="mailto:j@florius.com.ar"></a>
    
    
      <a class="fa fa-linkedin" href="https://www.linkedin.com/in/joaquin-azcarate"></a>
    
    
    <a class="fab fa-dev" href="https://dev.to/florius"></a>
    
    
    
    
    
  </div>
  <div class="right">
    
    
    
  </div>
</div>
<div class="clearfix"></div>

      
    </div>
  </div>
</header>


    <div class="post p2 p-responsive wrap animated fade-in-down" role="main">
      <div class="measure">
        


<div class="post-header mb2">
  <h1>Haskell para mentes imperativas</h1>
  <span class="post-meta">Dec 3, 2020</span><br>
  
  <span class="post-meta small read-time">
  
    13 minute read
  
  </span>
</div>

<article class="post-content">
  <p><em>El post original se puede leer en mi <a href="https://dev.to/florius/haskell-para-mentes-imperativas-4n7k">dev.to</a>.</em></p>

<p>Browseando YouTube encontré una playlist con un nombre muy interesante: “<a href="https://www.youtube.com/watch?v=Vgu82wiiZ90&amp;list=PLe7Ei6viL6jGp1Rfu0dil1JH1SHk9bgDV">Haskell for Imperative Programmers</a>” en donde el autor Philipp Hagenlocher explica conceptos de Haskell en videos cortos, concisos, con varios ejemplos y hasta algunos ejercicios. Lo que me inspiró a pensar cómo podría aprender alguien que tiene raíces en un paradigma imperativo. Por suerte no tuve que usar mucho la imaginación, ya que yo comencé con lenguajes imperativos, y en mi trabajo utilizo mayoritariamente el paradigma de objetos.</p>

<p>En este post quiero explorar algunas cosas que creo que me hubiesen servido para aprender Haskell. Teniendo una base en algún lenguaje imperativo, usar esta para programar en Haskell.</p>

<p>Si crees que entras en esta categoría, continúa leyendo.</p>

<h3 id="prefacio">Prefacio</h3>
<p>En este post haré uso de analogías y de patrones fuertemente asociados a la programación imperativa, de tal forma que la carga para aclimatarse al nuevo paradigma sea la menor posible, pero no considero esta la mejora forma de programar de forma funcional. Mi razonamiento es que: usando nuestro conocimiento previo ayude a comenzar a escalar la pendiente que es aprender un paradigma nuevo, y que esto a su vez dispare nuevas e interesantes investigaciones.</p>

<h2 id="variables">Variables</h2>

<p>Veo muy comúnmente la cara de espanto cuando uno habla de un lenguaje, como Haskell, donde la inmutabilidad está por defecto. Prontamente surge la pregunta de “cómo puedo asignar una variable” o “como puedo cambiar el valor de un contador”.
Recordemos que Haskell es un lenguaje de programación <a href="https://es.wikipedia.org/wiki/Turing_completo">Turing completo</a>, así que no es que <em>no se pueda</em> hacer, solo que hay que reconocer  que hay diferentes formas de afrontar un problema.</p>

<p>En Haskell, el símbolo <code class="language-plaintext highlighter-rouge">=</code> no representa una asignación, si no es más próximo a la idea matemática del <code class="language-plaintext highlighter-rouge">=</code> donde lo leemos (e interpretamos) como que algo <strong>es</strong> otra cosa.</p>

<p>En un lenguaje imperativo <code class="language-plaintext highlighter-rouge">x = 3</code> lo leemos como “asignamos el valor <code class="language-plaintext highlighter-rouge">3</code> a la variable <code class="language-plaintext highlighter-rouge">x</code>”, donde en un paradigma funcional, lo deberíamos interpretar como “<code class="language-plaintext highlighter-rouge">x</code> <em>es</em> 3”. <code class="language-plaintext highlighter-rouge">x</code> no puede cambiar. <code class="language-plaintext highlighter-rouge">x</code> simplemente <em>es</em>.</p>

<p>Se que esta justificación suele no quitar el pavor. Tras indagar más a fondo, suelo descubrir que hay dos temas distintos (pero muy  sobrelapados en los lenguajes imperativos):</p>

<p>Ponerle nombre a algo “intermedio”. Por ejemplo, si uno está escribiendo un método, y ve que hay una operación que se repite dos veces, suele ser considerado una buena práctica extraer lo común a una “variable” y ponerle nombre. Por ejemplo, podríamos empezar con un método:</p>

<figure class="highlight"><pre><code class="language-java" data-lang="java"><span class="nc">Int</span> <span class="nf">foo</span><span class="o">(</span><span class="nc">List</span><span class="o">&lt;</span><span class="nc">Int</span><span class="o">&gt;</span> <span class="n">xs</span><span class="o">)</span> <span class="o">{</span>
  <span class="k">if</span><span class="o">(</span><span class="n">xs</span><span class="o">.</span><span class="na">size</span><span class="o">()</span> <span class="o">&gt;</span> <span class="mi">3</span><span class="o">)</span>
    <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="o">;</span>
  <span class="k">else</span>
    <span class="k">return</span> <span class="n">xs</span><span class="o">.</span><span class="na">size</span><span class="o">();</span>
<span class="o">}</span></code></pre></figure>

<p>y luego refactorizar a algo como:</p>

<figure class="highlight"><pre><code class="language-java" data-lang="java"><span class="nc">Int</span> <span class="nf">foo</span><span class="o">(</span><span class="nc">List</span><span class="o">&lt;</span><span class="nc">Int</span><span class="o">&gt;</span> <span class="n">xs</span><span class="o">)</span> <span class="o">{</span>
  <span class="nc">Int</span> <span class="n">tamaño</span> <span class="o">=</span> <span class="n">xs</span><span class="o">.</span><span class="na">size</span><span class="o">();</span>
  <span class="k">if</span><span class="o">(</span><span class="n">tamaño</span> <span class="o">&gt;</span> <span class="mi">3</span><span class="o">)</span>
    <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="o">;</span>
  <span class="k">else</span>
    <span class="k">return</span> <span class="n">tamaño</span><span class="o">;</span>
<span class="o">}</span></code></pre></figure>

<p>En este acaso <code class="language-plaintext highlighter-rouge">tamaño</code> si bien es una “variable”, su intención no es variar en el contexto de la función. Es tan común y útil poder aseverar sobre qué cosas no cambian, que en otros lenguajes existe la idea que las “variables” puedan ser constantes (vaya oxímoron). Como <code class="language-plaintext highlighter-rouge">const</code> en JavaScript y PHP, <code class="language-plaintext highlighter-rouge">val</code>/<code class="language-plaintext highlighter-rouge">var</code>en Kotlin, variables en mayúsculas en Python o <code class="language-plaintext highlighter-rouge">final</code> en Java.</p>

<p>Lectores atentos pueden reconocer un potencial problema en esta refactorización, en donde no podemos asegurar 100% que el método <code class="language-plaintext highlighter-rouge">List::size()</code> no cambia la lista, y que invocarlo 2 veces como en el código de “antes” podría no ser igual al código de “despues” en donde solo se invoca una vez. Dado que conocemos la semántica de <code class="language-plaintext highlighter-rouge">List::size()</code>, podemos descansar que no va a alterar la lista; pero a veces, por la naturaleza de la mutabilidad, esto lleva a problemas. Toda una categoría de problemas que simplemente no pueden ocurrir en un mundo inmutable 😉.</p>

<p>Esto mismo podríamos lograr en Haskell con palabras reservadas como <code class="language-plaintext highlighter-rouge">let … in</code> o <code class="language-plaintext highlighter-rouge">where</code>.</p>

<figure class="highlight"><pre><code class="language-haskell" data-lang="haskell"><span class="n">foo</span> <span class="o">::</span> <span class="p">[</span><span class="kt">Int</span><span class="p">]</span> <span class="o">-&gt;</span> <span class="kt">Int</span>
<span class="n">foo</span> <span class="n">xs</span> <span class="o">=</span> <span class="kr">if</span> <span class="n">length</span> <span class="n">xs</span> <span class="kr">then</span>
         <span class="o">-</span><span class="mi">1</span>
       <span class="kr">else</span>
         <span class="n">length</span> <span class="n">xs</span></code></pre></figure>

<p>Y luego del refactor:</p>

<figure class="highlight"><pre><code class="language-haskell" data-lang="haskell"><span class="n">foo</span> <span class="o">::</span> <span class="p">[</span><span class="kt">Int</span><span class="p">]</span> <span class="o">-&gt;</span> <span class="kt">Int</span>
<span class="n">foo</span> <span class="n">xs</span> <span class="o">=</span>
   <span class="kr">let</span> <span class="n">tama</span><span class="err">ñ</span><span class="n">o</span> <span class="o">=</span> <span class="n">length</span> <span class="n">xs</span>
   <span class="kr">in</span> <span class="kr">if</span> <span class="n">tama</span><span class="err">ñ</span><span class="n">o</span> <span class="o">&gt;</span> <span class="mi">3</span> <span class="kr">then</span>
         <span class="o">-</span><span class="mi">1</span>
       <span class="kr">else</span>
         <span class="n">tama</span><span class="err">ñ</span><span class="n">o</span></code></pre></figure>

<p>o</p>

<figure class="highlight"><pre><code class="language-haskell" data-lang="haskell"><span class="n">foo</span> <span class="o">::</span> <span class="p">[</span><span class="kt">Int</span><span class="p">]</span> <span class="o">-&gt;</span> <span class="kt">Int</span>
<span class="n">foo</span> <span class="n">xs</span> <span class="o">=</span> <span class="kr">if</span> <span class="n">tama</span><span class="err">ñ</span><span class="n">o</span> <span class="o">&gt;</span> <span class="mi">3</span> <span class="kr">then</span>
         <span class="o">-</span><span class="mi">1</span>
       <span class="kr">else</span>
         <span class="n">tama</span><span class="err">ñ</span><span class="n">o</span>
   <span class="kr">where</span> <span class="n">tama</span><span class="err">ñ</span><span class="n">o</span> <span class="o">=</span> <span class="n">length</span> <span class="n">xs</span></code></pre></figure>

<p>Si bien hacen lo mismo, tienen sutiles diferencias a las entraré en detalle (pero si está aquí: <a href="https://wiki.haskell.org/Let_vs._Where">Let vs. Where - HaskellWiki</a>).</p>

<h2 id="cosas-que-cambian">Cosas que cambian</h2>

<p>El otro <em>sabor</em> de variables, es el de algo que cambia; y aquí, no tenemos suerte. No vamos a poder hacerlo. Pero eso no quita que podamos generar abstracciones para poder escribir algo que <em>se parezca</em>.</p>

<p>Pero antes de hablar de cosas que cambian, primero necesitamos estar de acuerdo en algunas convenciones. Cosas como</p>

<figure class="highlight"><pre><code class="language-c" data-lang="c"><span class="kt">void</span> <span class="nf">bar</span><span class="p">(</span><span class="kt">int</span><span class="o">*</span> <span class="n">x</span><span class="p">){</span>
    <span class="o">*</span><span class="n">x</span> <span class="o">+=</span> <span class="mi">4</span><span class="p">;</span>
<span class="p">}</span></code></pre></figure>

<p>En donde una función altera el valor que se le pasa son <em>el mal</em>, y no poder hacerlo es un <em>feature</em> (Aunque me encanta la idea de <a href="https://www.tweag.io/blog/2020-11-11-linear-dps/">Pure destination-passing style in Linear Haskell</a> cuando se apalanca del maravilloso sistema de tipos).</p>

<p>Algo mucho más sensible sería una función que tome el argumento y devuelva un nuevo número, resultado de la suma del argumento y 4.</p>

<p>Pero no siempre es tan sencillo. A veces tenemos varias mutaciones encadenadas, o unas que dependen de otras; por lo que podemos aplicar este algoritmo mental:
Cada vez que fuésemos a cambiar una variable, en realidad utilizaremos una nueva variable que sea el resultado del cambio, y de ahora en adelante, utilizar el nuevo nombre.</p>

<p>Por ejemplo, con la nueva herramienta de <code class="language-plaintext highlighter-rouge">let … in</code>:</p>

<figure class="highlight"><pre><code class="language-ruby" data-lang="ruby"><span class="k">def</span> <span class="nf">buzz</span> <span class="p">(</span><span class="n">n</span><span class="p">)</span>
  <span class="n">ret</span> <span class="o">=</span> <span class="n">n</span>
  <span class="n">ret</span> <span class="o">=</span> <span class="n">ret</span> <span class="o">%</span> <span class="mi">3</span>
  <span class="n">ret</span> <span class="o">=</span> <span class="n">ret</span> <span class="o">+</span><span class="mi">2</span>
  <span class="n">ret</span> <span class="o">=</span> <span class="n">ret</span> <span class="o">+</span> <span class="mi">5</span>
  <span class="n">ret</span> <span class="o">&gt;</span> <span class="mi">3</span>
<span class="k">end</span></code></pre></figure>

<figure class="highlight"><pre><code class="language-haskell" data-lang="haskell"><span class="n">buzz</span> <span class="n">n</span> <span class="o">=</span>
  <span class="kr">let</span> 
       <span class="n">x0</span> <span class="o">=</span> <span class="n">n</span>
       <span class="n">x1</span> <span class="o">=</span> <span class="n">x0</span> <span class="p">`</span><span class="n">mod</span><span class="p">`</span> <span class="mi">3</span>
       <span class="n">x2</span> <span class="o">=</span> <span class="n">x1</span> <span class="o">+</span> <span class="mi">2</span>
       <span class="n">x3</span> <span class="o">=</span> <span class="n">x2</span> <span class="o">+</span> <span class="mi">5</span>
  <span class="kt">In</span> <span class="n">x3</span> <span class="o">&gt;</span> <span class="mi">3</span></code></pre></figure>

<p>Si esta forma de escribir parece tediosa (lo es!), al final de la próxima sección volveremos sobre esto, pero todavía tenemos algo que podemos hacer. Revisemos qué es lo que es tan inconveniente: nombrar los pasos intermedios (<code class="language-plaintext highlighter-rouge">x0 - x3</code>) ¿Podemos no hacerlo?.</p>

<p>De esta forma nos acercamos a un patrón muy común en funcional, en donde uno tiene funciones intermedias que toman un valor, y devuelven “el nuevo” valor. Podemos concatenar estas operaciones (que hablan de cambios, no de variables).</p>

<p>Imaginemos el mismo ejemplo, pero vamos a re escribirlo en pequeñas funciones intermedias que cambien el valor.</p>

<figure class="highlight"><pre><code class="language-haskell" data-lang="haskell"><span class="n">buzz</span> <span class="n">n</span> <span class="o">=</span>
  <span class="kr">let</span> <span class="n">f0</span> <span class="n">x</span> <span class="o">=</span> <span class="n">x</span> <span class="p">`</span><span class="n">mod</span><span class="p">`</span> <span class="mi">3</span>
       <span class="n">f1</span> <span class="n">x</span> <span class="o">=</span> <span class="n">x</span> <span class="o">+</span> <span class="mi">2</span>
       <span class="n">f2</span> <span class="n">x</span> <span class="o">=</span> <span class="n">x</span> <span class="o">+</span> <span class="mi">5</span>
       <span class="n">f3</span> <span class="n">x</span> <span class="o">=</span> <span class="n">x</span> <span class="o">&gt;</span> <span class="mi">3</span>
      
       <span class="n">x0</span> <span class="o">=</span> <span class="n">n</span>
       <span class="n">x1</span> <span class="o">=</span> <span class="n">f0</span> <span class="n">x0</span>
       <span class="n">x2</span> <span class="o">=</span> <span class="n">f1</span> <span class="n">x1</span>
       <span class="n">x3</span> <span class="o">=</span> <span class="n">f2</span> <span class="n">x2</span>
  <span class="kt">In</span> <span class="n">f3</span> <span class="n">x3</span></code></pre></figure>

<p>Lamentablemente como es un ejemplo tan sintético, los nombres de las funciones intermedias serán malos; pero espero que puedan imaginarse que estas funciones sean cosas como <code class="language-plaintext highlighter-rouge">incrementarEdad</code>, <code class="language-plaintext highlighter-rouge">extraerDinero</code> u otro nombre más cercano al dominio de lo que esten programando.</p>

<p>Por ello voy a cambiar levemente el ejemplo para tener algo que sea más humanamente legible.</p>

<figure class="highlight"><pre><code class="language-haskell" data-lang="haskell"><span class="n">numeroValidador</span> <span class="n">x</span> <span class="o">=</span> <span class="n">x</span> <span class="p">`</span><span class="n">mod</span><span class="p">`</span> <span class="mi">3</span>
<span class="n">normalizarValidador</span> <span class="n">x</span> <span class="o">=</span> <span class="n">x</span> <span class="o">+</span> <span class="mi">2</span>
<span class="n">migrarCoeficiente</span> <span class="n">x</span> <span class="o">=</span> <span class="n">x</span> <span class="o">+</span> <span class="mi">5</span>
<span class="n">esValido</span> <span class="n">x</span> <span class="o">=</span> <span class="n">x</span> <span class="o">&gt;</span> <span class="mi">3</span>

<span class="n">tarjetaValida</span> <span class="n">n</span> <span class="o">=</span>
       <span class="n">x0</span> <span class="o">=</span> <span class="n">numeroValidador</span> <span class="n">n</span>
       <span class="n">x1</span> <span class="o">=</span> <span class="n">normalizarValidador</span> <span class="n">x0</span>
       <span class="n">x2</span> <span class="o">=</span> <span class="n">migrarCoeficiente</span> <span class="n">x1</span>
  <span class="kt">In</span> <span class="n">esValido</span> <span class="n">x2</span></code></pre></figure>

<p>Ahora podemos intentar pensar sobre nuestra <code class="language-plaintext highlighter-rouge">tarjetaValida</code>, donde lo que tiene que pasar es, en orden:</p>

<ol>
  <li>Dado un número pasado como parámetro (<code class="language-plaintext highlighter-rouge">n</code>)</li>
  <li>Tomamos el número validador (<code class="language-plaintext highlighter-rouge">x mod 3</code>)</li>
  <li>Lo normalizamos (<code class="language-plaintext highlighter-rouge">x + 2</code>)</li>
  <li>Migramos el coeficiente (<code class="language-plaintext highlighter-rouge">x + 5</code>)</li>
  <li>Y chequeamos que sea válido (<code class="language-plaintext highlighter-rouge">x &gt; 3</code>)</li>
</ol>

<p>Probablemente todavía no sea evidente, pero ahora podemos hacer un refactor de “inline” en cada variable intermedia (<code class="language-plaintext highlighter-rouge">x0 - x3</code>). Empecemos con <code class="language-plaintext highlighter-rouge">x3</code> e iremos ineline-ando de a una</p>

<figure class="highlight"><pre><code class="language-haskell" data-lang="haskell"><span class="n">tarjetaValida</span> <span class="n">n</span> <span class="o">=</span>
       <span class="n">x0</span> <span class="o">=</span> <span class="n">n</span>
       <span class="n">x1</span> <span class="o">=</span> <span class="n">numeroValidador</span> <span class="n">x0</span>
       <span class="n">x2</span> <span class="o">=</span> <span class="n">normalizarValidador</span> <span class="n">x1</span>
  <span class="kt">In</span> <span class="n">esValido</span> <span class="p">(</span><span class="n">migrarCoeficiente</span>  <span class="n">x1</span><span class="p">)</span></code></pre></figure>

<figure class="highlight"><pre><code class="language-haskell" data-lang="haskell"><span class="n">tarjetaValida</span> <span class="n">n</span> <span class="o">=</span>
       <span class="n">x0</span> <span class="o">=</span> <span class="n">n</span>
       <span class="n">x1</span> <span class="o">=</span> <span class="n">numeroValidador</span> <span class="n">x0</span>
  <span class="kt">In</span> <span class="n">esValido</span> <span class="p">(</span><span class="n">migrarCoeficiente</span>  <span class="p">(</span><span class="n">normalizarValidador</span>  <span class="n">x1</span><span class="p">))</span></code></pre></figure>

<figure class="highlight"><pre><code class="language-haskell" data-lang="haskell"><span class="n">tarjetaValida</span> <span class="n">n</span> <span class="o">=</span>
       <span class="n">x0</span> <span class="o">=</span> <span class="n">n</span>
  <span class="n">esValido</span>  <span class="p">(</span><span class="n">migrarCoeficiente</span> <span class="p">(</span><span class="n">normalizarValidador</span> <span class="p">(</span><span class="n">numeroValidador</span> <span class="n">x0</span><span class="p">)))</span></code></pre></figure>

<figure class="highlight"><pre><code class="language-haskell" data-lang="haskell"><span class="n">tarjetaValida</span> <span class="n">n</span> <span class="o">=</span>
  <span class="n">esValido</span>  <span class="p">(</span><span class="n">migrarCoeficiente</span> <span class="p">(</span><span class="n">normalizarValidador</span> <span class="p">(</span><span class="n">numeroValidador</span> <span class="n">n</span><span class="p">)))</span></code></pre></figure>

<p>Esto se parece mucho más a la descripción funcional de <code class="language-plaintext highlighter-rouge">tarjetaValida</code>, pero está escrito “al revés”. Por razones como esta existen <a href="https://hackage.haskell.org/package/base-4.14.0.0/docs/Data-Function.html#v:-38-">combinadores como <code class="language-plaintext highlighter-rouge">&amp;</code></a>, donde hablando mal y pronto, éste es el operador de <em>aplicación reversa</em>.</p>

<figure class="highlight"><pre><code class="language-haskell" data-lang="haskell"><span class="n">tarjetaValida</span> <span class="n">n</span> <span class="o">=</span>
  <span class="n">n</span> <span class="o">&amp;</span>
  <span class="n">numeroValidador</span> <span class="o">&amp;</span>
  <span class="n">normalizarValidador</span> <span class="o">&amp;</span>
  <span class="n">migrarCoeficiente</span> <span class="o">&amp;</span>
  <span class="n">esValido</span></code></pre></figure>

<p>Es interesante notar como todas nuestras funciones de “cambio” tienen la misma firma: <code class="language-plaintext highlighter-rouge">:: Int -&gt; Int</code>. De forma más genérica, son funciones que toman un valor de un tipo, y <em>devuelven</em> algo del mismo tipo.</p>

<h3 id="aplicación-parcial">Aplicación parcial</h3>
<p>Con el código que tenemos hasta aquí; podríamos cambiarlo para que <code class="language-plaintext highlighter-rouge">migrarCoeficiente</code> no siempre sume 5, si no que pueda ser parametrizable por una letra.
Sabiendo que hay una función que transforma una letra a un número <a href="https://hackage.haskell.org/package/base-4.14.0.0/docs/Data-Char.html#v:ord"><code class="language-plaintext highlighter-rouge">ord :: Char -&gt; Int</code></a> 
Podríamos cambiar <code class="language-plaintext highlighter-rouge">migrarCoeficiente</code> a:</p>

<figure class="highlight"><pre><code class="language-haskell" data-lang="haskell"><span class="n">migrarCoeficiente</span> <span class="o">::</span> <span class="kt">Char</span> <span class="o">-&gt;</span> <span class="kt">Int</span> <span class="o">-&gt;</span> <span class="kt">Int</span>
<span class="n">migrarCoeficiente</span> <span class="n">letra</span> <span class="n">x</span> <span class="o">=</span> <span class="n">x</span> <span class="o">+</span> <span class="p">(</span><span class="n">ord</span> <span class="n">caracter</span><span class="p">)</span></code></pre></figure>

<p>Ahora nuestra <code class="language-plaintext highlighter-rouge">tarjetaValida</code> no sufre muchos cambios:</p>

<figure class="highlight"><pre><code class="language-haskell" data-lang="haskell"><span class="n">tarjetaValida</span> <span class="n">n</span> <span class="o">=</span>
  <span class="n">n</span> <span class="o">&amp;</span>
  <span class="n">numeroValidador</span> <span class="o">&amp;</span>
  <span class="n">normalizarValidador</span> <span class="o">&amp;</span>
  <span class="n">migrarCoeficiente</span> <span class="sc">'f'</span> <span class="o">&amp;</span>
  <span class="n">esValido</span></code></pre></figure>

<p>Y eso fué gracias a <a href="http://aprendehaskell.es/content/OrdenSuperior.html">la currificación</a> de todas las funciones en Haskell!</p>

<h3 id="a-veces">A veces</h3>

<p>Otro gran “hack” que nos permite la mutabilidad, es la de cambiar el valor, pero solo según un flujo de control. Algo como:</p>

<figure class="highlight"><pre><code class="language-python" data-lang="python"><span class="k">def</span> <span class="nf">qux</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
  <span class="n">ret</span> <span class="o">=</span> <span class="n">n</span>
  <span class="k">if</span><span class="p">(</span><span class="n">ret</span> <span class="o">%</span> <span class="mi">3</span><span class="p">):</span>
    <span class="n">ret</span> <span class="o">=</span> <span class="mi">10</span>
  <span class="k">return</span> <span class="n">ret</span></code></pre></figure>

<p>En donde asignamos una variable que según uno u otro flujo de control puede cambiar. Siempre podremos reescribir esto de forma inmutable. Por ejemplo</p>

<figure class="highlight"><pre><code class="language-haskell" data-lang="haskell"><span class="n">qux</span> <span class="n">n</span> <span class="o">=</span> <span class="kr">if</span> <span class="n">n</span> <span class="p">`</span><span class="n">mod</span><span class="p">`</span> <span class="mi">3</span> <span class="o">==</span> <span class="mi">0</span> <span class="kr">then</span> <span class="mi">10</span> <span class="kr">else</span> <span class="n">n</span></code></pre></figure>

<p>Interesante notar que necesitamos un <code class="language-plaintext highlighter-rouge">else</code> que “deje todo como estaba”, pues no podemos “no hacer nada” en esta forma de escribirlo.</p>

<h2 id="monadas">Monadas</h2>

<p><em>(No podía ser un post de Haskell, y no mencionar a las monadas)</em></p>

<p>Una idea en la programación imperativa muy arraigada es que uno escribe una línea debajo de la otra, y esto hace que se ejecuten en ese orden.
Tan arraigada que casi no se considera una decisión del lenguaje, pero lo es! Es una decisión de diseño, y una que en un paradigma funcional es fácil escaparse.</p>

<p>Pero a veces, queremos ordenar una secuencia de cosas. Recordemos el ejemplo anterior de <code class="language-plaintext highlighter-rouge">buz</code>. Hay una monada (y probablemente <a href="http://aprendehaskell.es/content/MasMonadas.html">miles de</a> <a href="https://gist.github.com/sdiehl/8d991a718f7a9c80f54b">tutoriales de</a> <a href="https://wiki.haskell.org/State_Monad">como</a> <a href="https://mmhaskell.com/monads/state">implementarla</a>) llamada “state” que representa una forma de secuenciar operaciones, e ir mutando un valor. Por lo que uno podría escribir algo mucho más parecido a la forma imperativa:</p>

<figure class="highlight"><pre><code class="language-haskell" data-lang="haskell"><span class="cd">--            |----- Va a ir mutando un Int
</span>
<span class="c1">--            v   v- va a retornar un booleano
</span>
<span class="n">buz</span> <span class="o">::</span> <span class="kt">State</span> <span class="kt">Int</span> <span class="kt">Bool</span>
<span class="n">buz</span> <span class="o">=</span>
  <span class="n">get</span> <span class="o">&gt;&gt;=</span> <span class="p">(</span><span class="nf">\</span><span class="n">ret</span> <span class="o">-&gt;</span> <span class="n">set</span> <span class="p">(</span><span class="n">ret</span> <span class="p">`</span><span class="n">mod</span><span class="p">`</span> <span class="mi">3</span><span class="p">))</span> <span class="o">&gt;&gt;</span>
  <span class="n">get</span> <span class="o">&gt;&gt;=</span> <span class="p">(</span><span class="nf">\</span><span class="n">ret</span> <span class="o">-&gt;</span> <span class="n">put</span> <span class="p">(</span><span class="n">ret</span> <span class="o">+</span> <span class="mi">2</span><span class="p">))</span> <span class="o">&gt;&gt;</span>
  <span class="n">get</span> <span class="o">&gt;&gt;=</span> <span class="p">(</span><span class="nf">\</span><span class="n">ret</span> <span class="o">-&gt;</span> <span class="n">set</span> <span class="p">(</span><span class="n">ret</span> <span class="o">+</span> <span class="mi">5</span><span class="p">))</span> <span class="o">&gt;&gt;</span>
  <span class="n">get</span> <span class="o">&gt;&gt;=</span> <span class="p">(</span><span class="nf">\</span><span class="n">ret</span> <span class="o">-&gt;</span> <span class="n">return</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&gt;</span> <span class="mi">3</span><span class="p">))</span></code></pre></figure>

<p>Cada <code class="language-plaintext highlighter-rouge">ret</code> en este caso solo existe dentro del lambda <em>(todo lo que esté entre <code class="language-plaintext highlighter-rouge">(\</code> y <code class="language-plaintext highlighter-rouge">)</code>)</em></p>

<p>Muchas veces se ven las monadas con el <a href="https://es.wikipedia.org/wiki/Az%C3%BAcar_sint%C3%A1ctico"><em>azúcar sintáctico</em></a> de la notación <code class="language-plaintext highlighter-rouge">do</code>, que lo hace muy conveniente porque nos deja, como en un paradigma imperativo, escribir una línea debajo de la otra.</p>

<h3 id="monadas-cont">Monadas Cont.</h3>
<p>Otra gran razón para implementar una secuencia de operaciones, es que estas puedan fallar. El fallo en cualquier renglón invalide toda la computación. Pensemos en métodos que podrían lanzar excepciones.
Para esto también existe una monada! Y podríamos escribir algo como:</p>

<figure class="highlight"><pre><code class="language-swift" data-lang="swift"><span class="kd">func</span> <span class="nf">precio</span><span class="p">(</span><span class="n">itemConNombre</span> <span class="nv">nombre</span><span class="p">:</span> <span class="kt">String</span><span class="p">)</span> <span class="k">throws</span> <span class="p">{</span>
        <span class="k">guard</span> <span class="k">let</span> <span class="nv">item</span> <span class="o">=</span> <span class="n">inventario</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="k">else</span> <span class="p">{</span>
            <span class="k">throw</span> <span class="kt">Errores</span><span class="o">.</span><span class="nf">noExiste</span><span class="p">(</span><span class="nv">nombre</span><span class="p">:</span> <span class="n">nombre</span><span class="p">)</span>
        <span class="p">}</span>

        <span class="k">guard</span> <span class="n">item</span><span class="o">.</span><span class="n">cantidad</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="k">else</span> <span class="p">{</span>
            <span class="k">throw</span> <span class="kt">Errores</span><span class="o">.</span><span class="n">fueraDeStock</span>
        <span class="p">}</span>

        <span class="n">item</span><span class="o">.</span><span class="n">price</span>
<span class="p">}</span></code></pre></figure>

<p>De esta forma</p>

<figure class="highlight"><pre><code class="language-haskell" data-lang="haskell"><span class="kr">data</span> <span class="kt">Errores</span> <span class="o">=</span> <span class="kt">FueraDeStock</span> <span class="o">|</span> <span class="kt">NoExiste</span> <span class="kt">String</span>

<span class="n">buscar</span> <span class="o">::</span> <span class="kt">Inventario</span> <span class="o">-&gt;</span> <span class="kt">String</span> <span class="o">-&gt;</span> <span class="kt">Maybe</span> <span class="kt">Item</span>
<span class="n">buscar</span> <span class="o">=</span> <span class="p">(</span><span class="o">...</span><span class="p">)</span>

<span class="n">precio</span> <span class="o">::</span> <span class="kt">String</span> <span class="o">-&gt;</span> <span class="kt">Either</span> <span class="kt">Errores</span> <span class="kt">Int</span>
<span class="n">precio</span> <span class="n">nombre</span> <span class="o">=</span> <span class="kr">do</span>
    <span class="n">item</span> <span class="o">&lt;-</span> <span class="n">maybe</span> <span class="p">(</span><span class="kt">Left</span> <span class="p">(</span><span class="kt">NoExiste</span> <span class="n">nombre</span><span class="p">))</span> <span class="kt">Right</span> <span class="n">itemEncontrado</span> <span class="c1">-- (1)
</span>
    <span class="n">when</span> <span class="p">(</span><span class="n">cantidad</span> <span class="n">item</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">(</span><span class="kt">Left</span> <span class="kt">FueraDeStock</span><span class="p">)</span>
    <span class="n">return</span> <span class="n">precio</span> <span class="n">item</span>
  <span class="kr">where</span>
    <span class="n">itemEncontrado</span> <span class="o">::</span> <span class="kt">Maybe</span> <span class="kt">Item</span>
    <span class="n">itemEncontrado</span> <span class="o">=</span> <span class="n">buscar</span> <span class="n">inventario</span> <span class="n">nombre</span></code></pre></figure>

<p>La idea de la función <a href="https://hackage.haskell.org/package/base-4.14.0.0/docs/Prelude.html#v:maybe"><code class="language-plaintext highlighter-rouge">maybe</code></a> es poder extraer el valor de un <code class="language-plaintext highlighter-rouge">Maybe</code> (algo que puede o no estar). En el caso de que pueda fallar, <em>devolveremos</em> un <code class="language-plaintext highlighter-rouge">Left</code> (recordemos, representaría como lanzar una excepción), y en el caso que hubiese un <code class="language-plaintext highlighter-rouge">Item</code>, devolveremos un <code class="language-plaintext highlighter-rouge">Right</code>.</p>

<p>De esta forma, no <em>ejecutaremos</em> el <code class="language-plaintext highlighter-rouge">return</code> hasta que no pasen las dos condiciones anteriores.</p>

<h2 id="getter-y-setter">Getter y Setter</h2>

<p>Por último, quiero tocar algo de modelado, y la parte de lo que menos quiero escribir, porque es la que más se separa del paradigma; pero no obstante puedo ver cómo alguien puede estar tentado a utilizar herramientas de modelado de paradigmas que ya conoce, y pensar en un <a href="http://aprendehaskell.es/content/ClasesDeTipos.html"><em>record</em></a> es parecido a un objeto. Pero si así fuera… donde ponemos los métodos de este objeto?! (Sin entrar en el mundo de <a href="https://hackage.haskell.org/package/lens"><code class="language-plaintext highlighter-rouge">lens</code></a>).
No voy a objetar (🤭) porque se que yo lo hice durante mucho tiempo, así que mientras que sepamos que hay <em>tela para cortar</em>, por ahora puedo vivir con que pensemos que son objetos.</p>

<figure class="highlight"><pre><code class="language-csharp" data-lang="csharp"><span class="k">class</span> <span class="nc">Point</span>
<span class="p">{</span>
    <span class="k">public</span> <span class="kt">int</span> <span class="n">edad</span><span class="p">;</span>
<span class="p">}</span></code></pre></figure>

<p>podríamos escribirlo así:</p>

<figure class="highlight"><pre><code class="language-haskell" data-lang="haskell"><span class="kr">data</span> <span class="kt">Persona</span> <span class="o">=</span> <span class="kt">Persona</span> <span class="p">{</span> <span class="n">edad</span> <span class="o">::</span> <span class="kt">Int</span> <span class="p">}</span></code></pre></figure>

<p>Y tendremos <em>gratis</em> la función <code class="language-plaintext highlighter-rouge">edad :: Persona -&gt; Int</code> que “saca” la edad de una persona. Cual un getter, y la construcción:</p>

<figure class="highlight"><pre><code class="language-haskell" data-lang="haskell"><span class="n">cambiarEdad</span> <span class="o">::</span> <span class="kt">Int</span> <span class="o">-&gt;</span> <span class="kt">Persona</span> <span class="o">-&gt;</span> <span class="kt">Persona</span>
<span class="n">cambiarEdad</span> <span class="n">nuevaEdad</span> <span class="n">persona</span> <span class="o">=</span> <span class="n">persona</span> <span class="p">{</span> <span class="n">edad</span> <span class="o">=</span> <span class="n">nuevaEdad</span> <span class="p">}</span></code></pre></figure>

<p>Como un setter. Pero, como en OOP no estamos limitados a simplemente asignar el nuevo valor; podríamos hacer lo que queramos!</p>

<figure class="highlight"><pre><code class="language-haskell" data-lang="haskell"><span class="n">cambiarEdad</span> <span class="o">::</span> <span class="kt">Int</span> <span class="o">-&gt;</span> <span class="kt">Persona</span> <span class="o">-&gt;</span> <span class="kt">Persona</span>
<span class="n">cambiarEdad</span> <span class="n">nuevaEdad</span> <span class="n">persona</span> <span class="o">=</span> <span class="n">persona</span> <span class="p">{</span> <span class="n">edad</span> <span class="o">=</span> <span class="n">nuevaEdad</span> <span class="o">+</span> <span class="mi">3</span> <span class="p">}</span></code></pre></figure>

<p>Podemos encontrar un patrón recurrente, donde tengamos funciones que <em>terminen</em> con el tipo: <code class="language-plaintext highlighter-rouge">foo :: … -&gt; Algo -&gt; Algo</code>. Si recordamos el ejemplo de <code class="language-plaintext highlighter-rouge">tarjetaValida</code>, todas las funciones intermedias que teníamos eran del tipo: <code class="language-plaintext highlighter-rouge">:: Int -&gt; Int</code>, y el ejercicio al lector hubiera generado una función con el tipo: <code class="language-plaintext highlighter-rouge">:: Char -&gt; Int -&gt; Int</code>. Podemos pensar en toda esta familia de funciones como funciones que “alteran”. Además ahora ya sabemos cómo combinarlas!
Por ejemplo, concatenar listas  <a href="https://hackage.haskell.org/package/base-4.14.0.0/docs/GHC-List.html#v:-43--43-"><code class="language-plaintext highlighter-rouge">(++) :: [a] -&gt; [a] -&gt; [a] </code></a> en donde toma una primera lista y una segunda, y las “altera” (recordando que en realidad lo que hace es <em>devolver</em> una nueva lista) o tomar los primeros <code class="language-plaintext highlighter-rouge">n</code> elementos (<a href="https://hackage.haskell.org/package/base-4.14.0.0/docs/GHC-List.html#v:take"><code class="language-plaintext highlighter-rouge">take :: Int -&gt; [a] -&gt; [a]</code></a>). Hay muchísimas funciones como estas, y probablemente escribamos tantas de estas como “métodos” podrían tener nuestros objetos, si lo modelamos en OOP.</p>

<figure class="highlight"><pre><code class="language-kotlin" data-lang="kotlin"><span class="kd">class</span> <span class="nc">Persona</span><span class="p">(</span><span class="kd">var</span> <span class="py">edad</span><span class="p">:</span> <span class="nc">Int</span><span class="p">,</span> <span class="kd">var</span> <span class="py">altura</span><span class="p">:</span> <span class="nc">Int</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">fun</span> <span class="nf">crecer</span><span class="p">(</span><span class="n">años</span> <span class="p">:</span> <span class="nc">Int</span><span class="p">)</span> <span class="p">{</span>
                 <span class="k">this</span><span class="p">.</span><span class="n">edad</span> <span class="p">+=</span> <span class="n">años</span>
                 <span class="k">this</span><span class="p">.</span><span class="n">altura</span> <span class="p">+=</span> <span class="n">años</span><span class="p">*</span><span class="mi">2</span>
    <span class="p">}</span>
<span class="p">}</span></code></pre></figure>

<figure class="highlight"><pre><code class="language-haskell" data-lang="haskell"><span class="kr">data</span> <span class="kt">Persona</span> <span class="o">=</span> <span class="kt">Persona</span> <span class="p">{</span> <span class="n">edad</span> <span class="o">::</span> <span class="kt">Int</span><span class="p">,</span> <span class="n">altura</span> <span class="o">::</span> <span class="kt">Int</span> <span class="p">}</span>

<span class="n">crecer</span> <span class="o">::</span> <span class="kt">Int</span> <span class="o">-&gt;</span> <span class="kt">Persona</span> <span class="o">-&gt;</span> <span class="kt">Persona</span>
<span class="n">crecer</span> <span class="n">a</span><span class="err">ñ</span><span class="n">os</span> <span class="n">persona</span> <span class="o">=</span> <span class="kt">Persona</span> <span class="p">{</span> <span class="n">edad</span> <span class="o">=</span> <span class="n">edad</span> <span class="n">persona</span> <span class="o">+</span> <span class="n">a</span><span class="err">ñ</span><span class="n">os</span><span class="p">,</span>  <span class="n">altura</span> <span class="o">=</span> <span class="n">altura</span> <span class="n">persona</span> <span class="o">+</span> <span class="p">(</span><span class="n">a</span><span class="err">ñ</span><span class="n">os</span> <span class="o">*</span> <span class="mi">2</span><span class="p">)</span> <span class="p">}</span></code></pre></figure>

<h2 id="fin">Fin</h2>
<p>Espero que con estas herramientas, el prospecto de programar en Haskell sea menos aterrorizador.</p>

</article>







<div class="separator">
  <img src="/assets/cat-0fe72554239fb5bc68cc3b08063d5fb3d3984c6381e560b01fa8d5e35ed5a68e4741595a4929859029f18386c321ac391d55cccf60a51f08dd3148d38b5a44b7.png">
</div>


  <h3 class="related-post-title">Related Posts</h3>
  
  
  
    
    

    

    

  
    
    

    

    
      
      <div class="post ml2 related">
        <a href="/xpost/2021/01/31/inspiraciones/" class="post-link">
          <h4 class="post-title">Inspiraciones</h4>
        </a>
        <p class="post-summary">
          ¿Te pasa de querer programar algo y no saber que? tengo un bloqueo de ideas hace tiempo, quiero hacer algo con xxx y no se me ocurre qué hacer.
          <span class="related-categories">
            <a href="/categories#xpost">#xpost</a>
          </span>
        </p>
      </div>
      
      
    

  
    
    

    

    

  
    
    

    

    
      
      <div class="post ml2 related">
        <a href="/xpost/2020/09/14/koncierge-una-libreria-para-segmentar-usuarios/" class="post-link">
          <h4 class="post-title">koncierge Una librería para segmentar usuarios</h4>
        </a>
        <p class="post-summary">
          La historia de una librería para evaluar variantes de tests AB, dado una definición de un experimento con un DSL parecido a Mongo y un contexto.
          <span class="related-categories">
            <a href="/categories#xpost">#xpost</a>
          </span>
        </p>
      </div>
      
      
    

  
    
    

    

    
      
      <div class="post ml2 related">
        <a href="/xpost/2019/07/10/the-essence-of-event-sourcing/" class="post-link">
          <h4 class="post-title">The essence of Event Sourcing</h4>
        </a>
        <p class="post-summary">
          Event Sourcing is a somewhat trending topic, and you can find a lot of blog posts on what event sourcing supposedly is. I’ll throw my wrench in the works and try to explain what I see as “Event Sourcing”.
          <span class="related-categories">
            <a href="/categories#xpost">#xpost</a>
          </span>
        </p>
      </div>
      
      
        
  



      </div>
    </div>
  </div>

  <footer class="center">
  <div class="measure">
    <small>
      Theme heavily inspired in <a href="http://johnotander.com">John Otander</a>' <a href="https://github.com/johno/pixyll">pixyll</a>.
    </small>
  </div>
</footer>
<!-- AnchorJS -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/anchor-js/4.2.0/anchor.min.js"></script>
<script>
    anchors.options.visible = 'touch';
    anchors.add('article h2, article h3, article h4, article h5, article h6');
</script>

</body>
</html>
