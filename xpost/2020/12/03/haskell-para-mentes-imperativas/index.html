<!DOCTYPE html>
<html lang="en">
<head>
    
    <!-- Global site tag (gtag.js) - Google Analytics -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-689SEV7MTT"></script>
    <script>window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date()); gtag('config', 'G-689SEV7MTT', { cookie_domain: 'blog.florius.com.ar', cookie_flags: 'SameSite=None;Secure' });</script>
    
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <link rel="dns-prefetch" href="//fonts.googleapis.com">
    <link rel="dns-prefetch" href="//fonts.gstatic.com">
    <link rel="dns-prefetch" href="//maxcdn.bootstrapcdn.com">
    <link rel="dns-prefetch" href="//cdnjs.cloudflare.com">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel="manifest" type="application/manifest+json; charset=utf-8" href="/site.webmanifest" />
    <meta name="robots" content="all">
    <meta name="author" content="florius">
    
    <meta name="keywords" content="xpost">
    <link rel="alternate" type="application/rss+xml" title="RSS Feed for Florius’ Blog" href="/feed.xml" />
    <!-- Begin Jekyll SEO tag v2.7.1 -->
<title>Haskell para mentes imperativas | Florius’ Blog</title>
<meta name="generator" content="Jekyll v4.2.0" />
<meta property="og:title" content="Haskell para mentes imperativas" />
<meta name="author" content="Joaquin 'Florius' Azcarate" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="El post original se puede leer en mi dev.to. Browseando YouTube encontré una playlist con un nombre muy interesante: “Haskell for Imperative Programmers” en donde el autor Philipp Hagenlocher explica conceptos de Haskell en videos cortos, concisos, con varios ejemplos y hasta algunos ejercicios. Lo que me inspiró a pensar cómo podría aprender alguien que tiene raíces en un paradigma imperativo. Por suerte no tuve que usar mucho la imaginación, ya que yo comencé con lenguajes imperativos, y en mi trabajo utilizo mayoritariamente el paradigma de objetos. En este post quiero explorar algunas cosas que creo que me hubiesen servido para aprender Haskell. Teniendo una base en algún lenguaje imperativo, usar esta para programar en Haskell. Si crees que entras en esta categoría, continúa leyendo. Prefacio En este post haré uso de analogías y de patrones fuertemente asociados a la programación imperativa, de tal forma que la carga para aclimatarse al nuevo paradigma sea la menor posible, pero no considero esta la mejora forma de programar de forma funcional. Mi razonamiento es que: usando nuestro conocimiento previo ayude a comenzar a escalar la pendiente que es aprender un paradigma nuevo, y que esto a su vez dispare nuevas e interesantes investigaciones. Variables Veo muy comúnmente la cara de espanto cuando uno habla de un lenguaje, como Haskell, donde la inmutabilidad está por defecto. Prontamente surge la pregunta de “cómo puedo asignar una variable” o “como puedo cambiar el valor de un contador”. Recordemos que Haskell es un lenguaje de programación Turing completo, así que no es que no se pueda hacer, solo que hay que reconocer que hay diferentes formas de afrontar un problema. En Haskell, el símbolo = no representa una asignación, si no es más próximo a la idea matemática del = donde lo leemos (e interpretamos) como que algo es otra cosa. En un lenguaje imperativo x = 3 lo leemos como “asignamos el valor 3 a la variable x”, donde en un paradigma funcional, lo deberíamos interpretar como “x es 3”. x no puede cambiar. x simplemente es. Se que esta justificación suele no quitar el pavor. Tras indagar más a fondo, suelo descubrir que hay dos temas distintos (pero muy sobrelapados en los lenguajes imperativos): Ponerle nombre a algo “intermedio”. Por ejemplo, si uno está escribiendo un método, y ve que hay una operación que se repite dos veces, suele ser considerado una buena práctica extraer lo común a una “variable” y ponerle nombre. Por ejemplo, podríamos empezar con un método: Int foo(List&lt;Int&gt; xs) { if(xs.size() &gt; 3) return -1; else return xs.size(); } y luego refactorizar a algo como: Int foo(List&lt;Int&gt; xs) { Int tamaño = xs.size(); if(tamaño &gt; 3) return -1; else return tamaño; } En este acaso tamaño si bien es una “variable”, su intención no es variar en el contexto de la función. Es tan común y útil poder aseverar sobre qué cosas no cambian, que en otros lenguajes existe la idea que las “variables” puedan ser constantes (vaya oxímoron). Como const en JavaScript y PHP, val/varen Kotlin, variables en mayúsculas en Python o final en Java. Lectores atentos pueden reconocer un potencial problema en esta refactorización, en donde no podemos asegurar 100% que el método List::size() no cambia la lista, y que invocarlo 2 veces como en el código de “antes” podría no ser igual al código de “despues” en donde solo se invoca una vez. Dado que conocemos la semántica de List::size(), podemos descansar que no va a alterar la lista; pero a veces, por la naturaleza de la mutabilidad, esto lleva a problemas. Toda una categoría de problemas que simplemente no pueden ocurrir en un mundo inmutable 😉. Esto mismo podríamos lograr en Haskell con palabras reservadas como let … in o where. foo :: [Int] -&gt; Int foo xs = if length xs then -1 else length xs Y luego del refactor: foo :: [Int] -&gt; Int foo xs = let tamaño = length xs in if tamaño &gt; 3 then -1 else tamaño o foo :: [Int] -&gt; Int foo xs = if tamaño &gt; 3 then -1 else tamaño where tamaño = length xs Si bien hacen lo mismo, tienen sutiles diferencias a las entraré en detalle (pero si está aquí: Let vs. Where - HaskellWiki). Cosas que cambian El otro sabor de variables, es el de algo que cambia; y aquí, no tenemos suerte. No vamos a poder hacerlo. Pero eso no quita que podamos generar abstracciones para poder escribir algo que se parezca. Pero antes de hablar de cosas que cambian, primero necesitamos estar de acuerdo en algunas convenciones. Cosas como void bar(int* x){ *x += 4; } En donde una función altera el valor que se le pasa son el mal, y no poder hacerlo es un feature (Aunque me encanta la idea de Pure destination-passing style in Linear Haskell cuando se apalanca del maravilloso sistema de tipos). Algo mucho más sensible sería una función que tome el argumento y devuelva un nuevo número, resultado de la suma del argumento y 4. Pero no siempre es tan sencillo. A veces tenemos varias mutaciones encadenadas, o unas que dependen de otras; por lo que podemos aplicar este algoritmo mental: Cada vez que fuésemos a cambiar una variable, en realidad utilizaremos una nueva variable que sea el resultado del cambio, y de ahora en adelante, utilizar el nuevo nombre. Por ejemplo, con la nueva herramienta de let … in: def buzz (n) ret = n ret = ret % 3 ret = ret +2 ret = ret + 5 ret &gt; 3 end buzz n = let x0 = n x1 = x0 `mod` 3 x2 = x1 + 2 x3 = x2 + 5 In x3 &gt; 3 Si esta forma de escribir parece tediosa (lo es!), al final de la próxima sección volveremos sobre esto, pero todavía tenemos algo que podemos hacer. Revisemos qué es lo que es tan inconveniente: nombrar los pasos intermedios (x0 - x3) ¿Podemos no hacerlo?. De esta forma nos acercamos a un patrón muy común en funcional, en donde uno tiene funciones intermedias que toman un valor, y devuelven “el nuevo” valor. Podemos concatenar estas operaciones (que hablan de cambios, no de variables). Imaginemos el mismo ejemplo, pero vamos a re escribirlo en pequeñas funciones intermedias que cambien el valor. buzz n = let f0 x = x `mod` 3 f1 x = x + 2 f2 x = x + 5 f3 x = x &gt; 3 x0 = n x1 = f0 x0 x2 = f1 x1 x3 = f2 x2 In f3 x3 Lamentablemente como es un ejemplo tan sintético, los nombres de las funciones intermedias serán malos; pero espero que puedan imaginarse que estas funciones sean cosas como incrementarEdad, extraerDinero u otro nombre más cercano al dominio de lo que esten programando. Por ello voy a cambiar levemente el ejemplo para tener algo que sea más humanamente legible. numeroValidador x = x `mod` 3 normalizarValidador x = x + 2 migrarCoeficiente x = x + 5 esValido x = x &gt; 3 tarjetaValida n = x0 = numeroValidador n x1 = normalizarValidador x0 x2 = migrarCoeficiente x1 In esValido x2 Ahora podemos intentar pensar sobre nuestra tarjetaValida, donde lo que tiene que pasar es, en orden: Dado un número pasado como parámetro (n) Tomamos el número validador (x mod 3) Lo normalizamos (x + 2) Migramos el coeficiente (x + 5) Y chequeamos que sea válido (x &gt; 3) Probablemente todavía no sea evidente, pero ahora podemos hacer un refactor de “inline” en cada variable intermedia (x0 - x3). Empecemos con x3 e iremos ineline-ando de a una tarjetaValida n = x0 = n x1 = numeroValidador x0 x2 = normalizarValidador x1 In esValido (migrarCoeficiente x1) tarjetaValida n = x0 = n x1 = numeroValidador x0 In esValido (migrarCoeficiente (normalizarValidador x1)) tarjetaValida n = x0 = n esValido (migrarCoeficiente (normalizarValidador (numeroValidador x0))) tarjetaValida n = esValido (migrarCoeficiente (normalizarValidador (numeroValidador n))) Esto se parece mucho más a la descripción funcional de tarjetaValida, pero está escrito “al revés”. Por razones como esta existen combinadores como &amp;, donde hablando mal y pronto, éste es el operador de aplicación reversa. tarjetaValida n = n &amp; numeroValidador &amp; normalizarValidador &amp; migrarCoeficiente &amp; esValido Es interesante notar como todas nuestras funciones de “cambio” tienen la misma firma: :: Int -&gt; Int. De forma más genérica, son funciones que toman un valor de un tipo, y devuelven algo del mismo tipo. Aplicación parcial Con el código que tenemos hasta aquí; podríamos cambiarlo para que migrarCoeficiente no siempre sume 5, si no que pueda ser parametrizable por una letra. Sabiendo que hay una función que transforma una letra a un número ord :: Char -&gt; Int Podríamos cambiar migrarCoeficiente a: migrarCoeficiente :: Char -&gt; Int -&gt; Int migrarCoeficiente letra x = x + (ord caracter) Ahora nuestra tarjetaValida no sufre muchos cambios: tarjetaValida n = n &amp; numeroValidador &amp; normalizarValidador &amp; migrarCoeficiente &#39;f&#39; &amp; esValido Y eso fué gracias a la currificación de todas las funciones en Haskell! A veces Otro gran “hack” que nos permite la mutabilidad, es la de cambiar el valor, pero solo según un flujo de control. Algo como: def qux(n): ret = n if(ret % 3): ret = 10 return ret En donde asignamos una variable que según uno u otro flujo de control puede cambiar. Siempre podremos reescribir esto de forma inmutable. Por ejemplo qux n = if n `mod` 3 == 0 then 10 else n Interesante notar que necesitamos un else que “deje todo como estaba”, pues no podemos “no hacer nada” en esta forma de escribirlo. Monadas (No podía ser un post de Haskell, y no mencionar a las monadas) Una idea en la programación imperativa muy arraigada es que uno escribe una línea debajo de la otra, y esto hace que se ejecuten en ese orden. Tan arraigada que casi no se considera una decisión del lenguaje, pero lo es! Es una decisión de diseño, y una que en un paradigma funcional es fácil escaparse. Pero a veces, queremos ordenar una secuencia de cosas. Recordemos el ejemplo anterior de buz. Hay una monada (y probablemente miles de tutoriales de como implementarla) llamada “state” que representa una forma de secuenciar operaciones, e ir mutando un valor. Por lo que uno podría escribir algo mucho más parecido a la forma imperativa: -- |----- Va a ir mutando un Int -- v v- va a retornar un booleano buz :: State Int Bool buz = get &gt;&gt;= (\ret -&gt; set (ret `mod` 3)) &gt;&gt; get &gt;&gt;= (\ret -&gt; put (ret + 2)) &gt;&gt; get &gt;&gt;= (\ret -&gt; set (ret + 5)) &gt;&gt; get &gt;&gt;= (\ret -&gt; return (ret &gt; 3)) Cada ret en este caso solo existe dentro del lambda (todo lo que esté entre (\ y )) Muchas veces se ven las monadas con el azúcar sintáctico de la notación do, que lo hace muy conveniente porque nos deja, como en un paradigma imperativo, escribir una línea debajo de la otra. Monadas Cont. Otra gran razón para implementar una secuencia de operaciones, es que estas puedan fallar. El fallo en cualquier renglón invalide toda la computación. Pensemos en métodos que podrían lanzar excepciones. Para esto también existe una monada! Y podríamos escribir algo como: func precio(itemConNombre nombre: String) throws { guard let item = inventario[name] else { throw Errores.noExiste(nombre: nombre) } guard item.cantidad &gt; 0 else { throw Errores.fueraDeStock } item.price } De esta forma data Errores = FueraDeStock | NoExiste String buscar :: Inventario -&gt; String -&gt; Maybe Item buscar = (...) precio :: String -&gt; Either Errores Int precio nombre = do item &lt;- maybe (Left (NoExiste nombre)) Right itemEncontrado -- (1) when (cantidad item &gt; 0) (Left FueraDeStock) return precio item where itemEncontrado :: Maybe Item itemEncontrado = buscar inventario nombre La idea de la función maybe es poder extraer el valor de un Maybe (algo que puede o no estar). En el caso de que pueda fallar, devolveremos un Left (recordemos, representaría como lanzar una excepción), y en el caso que hubiese un Item, devolveremos un Right. De esta forma, no ejecutaremos el return hasta que no pasen las dos condiciones anteriores. Getter y Setter Por último, quiero tocar algo de modelado, y la parte de lo que menos quiero escribir, porque es la que más se separa del paradigma; pero no obstante puedo ver cómo alguien puede estar tentado a utilizar herramientas de modelado de paradigmas que ya conoce, y pensar en un record es parecido a un objeto. Pero si así fuera… donde ponemos los métodos de este objeto?! (Sin entrar en el mundo de lens). No voy a objetar (🤭) porque se que yo lo hice durante mucho tiempo, así que mientras que sepamos que hay tela para cortar, por ahora puedo vivir con que pensemos que son objetos. class Point { public int edad; } podríamos escribirlo así: data Persona = Persona { edad :: Int } Y tendremos gratis la función edad :: Persona -&gt; Int que “saca” la edad de una persona. Cual un getter, y la construcción: cambiarEdad :: Int -&gt; Persona -&gt; Persona cambiarEdad nuevaEdad persona = persona { edad = nuevaEdad } Como un setter. Pero, como en OOP no estamos limitados a simplemente asignar el nuevo valor; podríamos hacer lo que queramos! cambiarEdad :: Int -&gt; Persona -&gt; Persona cambiarEdad nuevaEdad persona = persona { edad = nuevaEdad + 3 } Podemos encontrar un patrón recurrente, donde tengamos funciones que terminen con el tipo: foo :: … -&gt; Algo -&gt; Algo. Si recordamos el ejemplo de tarjetaValida, todas las funciones intermedias que teníamos eran del tipo: :: Int -&gt; Int, y el ejercicio al lector hubiera generado una función con el tipo: :: Char -&gt; Int -&gt; Int. Podemos pensar en toda esta familia de funciones como funciones que “alteran”. Además ahora ya sabemos cómo combinarlas! Por ejemplo, concatenar listas (++) :: [a] -&gt; [a] -&gt; [a] en donde toma una primera lista y una segunda, y las “altera” (recordando que en realidad lo que hace es devolver una nueva lista) o tomar los primeros n elementos (take :: Int -&gt; [a] -&gt; [a]). Hay muchísimas funciones como estas, y probablemente escribamos tantas de estas como “métodos” podrían tener nuestros objetos, si lo modelamos en OOP. class Persona(var edad: Int, var altura: Int) { fun crecer(años : Int) { this.edad += años this.altura += años*2 } } data Persona = Persona { edad :: Int, altura :: Int } crecer :: Int -&gt; Persona -&gt; Persona crecer años persona = Persona { edad = edad persona + años, altura = altura persona + (años * 2) } Fin Espero que con estas herramientas, el prospecto de programar en Haskell sea menos aterrorizador." />
<meta property="og:description" content="El post original se puede leer en mi dev.to. Browseando YouTube encontré una playlist con un nombre muy interesante: “Haskell for Imperative Programmers” en donde el autor Philipp Hagenlocher explica conceptos de Haskell en videos cortos, concisos, con varios ejemplos y hasta algunos ejercicios. Lo que me inspiró a pensar cómo podría aprender alguien que tiene raíces en un paradigma imperativo. Por suerte no tuve que usar mucho la imaginación, ya que yo comencé con lenguajes imperativos, y en mi trabajo utilizo mayoritariamente el paradigma de objetos. En este post quiero explorar algunas cosas que creo que me hubiesen servido para aprender Haskell. Teniendo una base en algún lenguaje imperativo, usar esta para programar en Haskell. Si crees que entras en esta categoría, continúa leyendo. Prefacio En este post haré uso de analogías y de patrones fuertemente asociados a la programación imperativa, de tal forma que la carga para aclimatarse al nuevo paradigma sea la menor posible, pero no considero esta la mejora forma de programar de forma funcional. Mi razonamiento es que: usando nuestro conocimiento previo ayude a comenzar a escalar la pendiente que es aprender un paradigma nuevo, y que esto a su vez dispare nuevas e interesantes investigaciones. Variables Veo muy comúnmente la cara de espanto cuando uno habla de un lenguaje, como Haskell, donde la inmutabilidad está por defecto. Prontamente surge la pregunta de “cómo puedo asignar una variable” o “como puedo cambiar el valor de un contador”. Recordemos que Haskell es un lenguaje de programación Turing completo, así que no es que no se pueda hacer, solo que hay que reconocer que hay diferentes formas de afrontar un problema. En Haskell, el símbolo = no representa una asignación, si no es más próximo a la idea matemática del = donde lo leemos (e interpretamos) como que algo es otra cosa. En un lenguaje imperativo x = 3 lo leemos como “asignamos el valor 3 a la variable x”, donde en un paradigma funcional, lo deberíamos interpretar como “x es 3”. x no puede cambiar. x simplemente es. Se que esta justificación suele no quitar el pavor. Tras indagar más a fondo, suelo descubrir que hay dos temas distintos (pero muy sobrelapados en los lenguajes imperativos): Ponerle nombre a algo “intermedio”. Por ejemplo, si uno está escribiendo un método, y ve que hay una operación que se repite dos veces, suele ser considerado una buena práctica extraer lo común a una “variable” y ponerle nombre. Por ejemplo, podríamos empezar con un método: Int foo(List&lt;Int&gt; xs) { if(xs.size() &gt; 3) return -1; else return xs.size(); } y luego refactorizar a algo como: Int foo(List&lt;Int&gt; xs) { Int tamaño = xs.size(); if(tamaño &gt; 3) return -1; else return tamaño; } En este acaso tamaño si bien es una “variable”, su intención no es variar en el contexto de la función. Es tan común y útil poder aseverar sobre qué cosas no cambian, que en otros lenguajes existe la idea que las “variables” puedan ser constantes (vaya oxímoron). Como const en JavaScript y PHP, val/varen Kotlin, variables en mayúsculas en Python o final en Java. Lectores atentos pueden reconocer un potencial problema en esta refactorización, en donde no podemos asegurar 100% que el método List::size() no cambia la lista, y que invocarlo 2 veces como en el código de “antes” podría no ser igual al código de “despues” en donde solo se invoca una vez. Dado que conocemos la semántica de List::size(), podemos descansar que no va a alterar la lista; pero a veces, por la naturaleza de la mutabilidad, esto lleva a problemas. Toda una categoría de problemas que simplemente no pueden ocurrir en un mundo inmutable 😉. Esto mismo podríamos lograr en Haskell con palabras reservadas como let … in o where. foo :: [Int] -&gt; Int foo xs = if length xs then -1 else length xs Y luego del refactor: foo :: [Int] -&gt; Int foo xs = let tamaño = length xs in if tamaño &gt; 3 then -1 else tamaño o foo :: [Int] -&gt; Int foo xs = if tamaño &gt; 3 then -1 else tamaño where tamaño = length xs Si bien hacen lo mismo, tienen sutiles diferencias a las entraré en detalle (pero si está aquí: Let vs. Where - HaskellWiki). Cosas que cambian El otro sabor de variables, es el de algo que cambia; y aquí, no tenemos suerte. No vamos a poder hacerlo. Pero eso no quita que podamos generar abstracciones para poder escribir algo que se parezca. Pero antes de hablar de cosas que cambian, primero necesitamos estar de acuerdo en algunas convenciones. Cosas como void bar(int* x){ *x += 4; } En donde una función altera el valor que se le pasa son el mal, y no poder hacerlo es un feature (Aunque me encanta la idea de Pure destination-passing style in Linear Haskell cuando se apalanca del maravilloso sistema de tipos). Algo mucho más sensible sería una función que tome el argumento y devuelva un nuevo número, resultado de la suma del argumento y 4. Pero no siempre es tan sencillo. A veces tenemos varias mutaciones encadenadas, o unas que dependen de otras; por lo que podemos aplicar este algoritmo mental: Cada vez que fuésemos a cambiar una variable, en realidad utilizaremos una nueva variable que sea el resultado del cambio, y de ahora en adelante, utilizar el nuevo nombre. Por ejemplo, con la nueva herramienta de let … in: def buzz (n) ret = n ret = ret % 3 ret = ret +2 ret = ret + 5 ret &gt; 3 end buzz n = let x0 = n x1 = x0 `mod` 3 x2 = x1 + 2 x3 = x2 + 5 In x3 &gt; 3 Si esta forma de escribir parece tediosa (lo es!), al final de la próxima sección volveremos sobre esto, pero todavía tenemos algo que podemos hacer. Revisemos qué es lo que es tan inconveniente: nombrar los pasos intermedios (x0 - x3) ¿Podemos no hacerlo?. De esta forma nos acercamos a un patrón muy común en funcional, en donde uno tiene funciones intermedias que toman un valor, y devuelven “el nuevo” valor. Podemos concatenar estas operaciones (que hablan de cambios, no de variables). Imaginemos el mismo ejemplo, pero vamos a re escribirlo en pequeñas funciones intermedias que cambien el valor. buzz n = let f0 x = x `mod` 3 f1 x = x + 2 f2 x = x + 5 f3 x = x &gt; 3 x0 = n x1 = f0 x0 x2 = f1 x1 x3 = f2 x2 In f3 x3 Lamentablemente como es un ejemplo tan sintético, los nombres de las funciones intermedias serán malos; pero espero que puedan imaginarse que estas funciones sean cosas como incrementarEdad, extraerDinero u otro nombre más cercano al dominio de lo que esten programando. Por ello voy a cambiar levemente el ejemplo para tener algo que sea más humanamente legible. numeroValidador x = x `mod` 3 normalizarValidador x = x + 2 migrarCoeficiente x = x + 5 esValido x = x &gt; 3 tarjetaValida n = x0 = numeroValidador n x1 = normalizarValidador x0 x2 = migrarCoeficiente x1 In esValido x2 Ahora podemos intentar pensar sobre nuestra tarjetaValida, donde lo que tiene que pasar es, en orden: Dado un número pasado como parámetro (n) Tomamos el número validador (x mod 3) Lo normalizamos (x + 2) Migramos el coeficiente (x + 5) Y chequeamos que sea válido (x &gt; 3) Probablemente todavía no sea evidente, pero ahora podemos hacer un refactor de “inline” en cada variable intermedia (x0 - x3). Empecemos con x3 e iremos ineline-ando de a una tarjetaValida n = x0 = n x1 = numeroValidador x0 x2 = normalizarValidador x1 In esValido (migrarCoeficiente x1) tarjetaValida n = x0 = n x1 = numeroValidador x0 In esValido (migrarCoeficiente (normalizarValidador x1)) tarjetaValida n = x0 = n esValido (migrarCoeficiente (normalizarValidador (numeroValidador x0))) tarjetaValida n = esValido (migrarCoeficiente (normalizarValidador (numeroValidador n))) Esto se parece mucho más a la descripción funcional de tarjetaValida, pero está escrito “al revés”. Por razones como esta existen combinadores como &amp;, donde hablando mal y pronto, éste es el operador de aplicación reversa. tarjetaValida n = n &amp; numeroValidador &amp; normalizarValidador &amp; migrarCoeficiente &amp; esValido Es interesante notar como todas nuestras funciones de “cambio” tienen la misma firma: :: Int -&gt; Int. De forma más genérica, son funciones que toman un valor de un tipo, y devuelven algo del mismo tipo. Aplicación parcial Con el código que tenemos hasta aquí; podríamos cambiarlo para que migrarCoeficiente no siempre sume 5, si no que pueda ser parametrizable por una letra. Sabiendo que hay una función que transforma una letra a un número ord :: Char -&gt; Int Podríamos cambiar migrarCoeficiente a: migrarCoeficiente :: Char -&gt; Int -&gt; Int migrarCoeficiente letra x = x + (ord caracter) Ahora nuestra tarjetaValida no sufre muchos cambios: tarjetaValida n = n &amp; numeroValidador &amp; normalizarValidador &amp; migrarCoeficiente &#39;f&#39; &amp; esValido Y eso fué gracias a la currificación de todas las funciones en Haskell! A veces Otro gran “hack” que nos permite la mutabilidad, es la de cambiar el valor, pero solo según un flujo de control. Algo como: def qux(n): ret = n if(ret % 3): ret = 10 return ret En donde asignamos una variable que según uno u otro flujo de control puede cambiar. Siempre podremos reescribir esto de forma inmutable. Por ejemplo qux n = if n `mod` 3 == 0 then 10 else n Interesante notar que necesitamos un else que “deje todo como estaba”, pues no podemos “no hacer nada” en esta forma de escribirlo. Monadas (No podía ser un post de Haskell, y no mencionar a las monadas) Una idea en la programación imperativa muy arraigada es que uno escribe una línea debajo de la otra, y esto hace que se ejecuten en ese orden. Tan arraigada que casi no se considera una decisión del lenguaje, pero lo es! Es una decisión de diseño, y una que en un paradigma funcional es fácil escaparse. Pero a veces, queremos ordenar una secuencia de cosas. Recordemos el ejemplo anterior de buz. Hay una monada (y probablemente miles de tutoriales de como implementarla) llamada “state” que representa una forma de secuenciar operaciones, e ir mutando un valor. Por lo que uno podría escribir algo mucho más parecido a la forma imperativa: -- |----- Va a ir mutando un Int -- v v- va a retornar un booleano buz :: State Int Bool buz = get &gt;&gt;= (\ret -&gt; set (ret `mod` 3)) &gt;&gt; get &gt;&gt;= (\ret -&gt; put (ret + 2)) &gt;&gt; get &gt;&gt;= (\ret -&gt; set (ret + 5)) &gt;&gt; get &gt;&gt;= (\ret -&gt; return (ret &gt; 3)) Cada ret en este caso solo existe dentro del lambda (todo lo que esté entre (\ y )) Muchas veces se ven las monadas con el azúcar sintáctico de la notación do, que lo hace muy conveniente porque nos deja, como en un paradigma imperativo, escribir una línea debajo de la otra. Monadas Cont. Otra gran razón para implementar una secuencia de operaciones, es que estas puedan fallar. El fallo en cualquier renglón invalide toda la computación. Pensemos en métodos que podrían lanzar excepciones. Para esto también existe una monada! Y podríamos escribir algo como: func precio(itemConNombre nombre: String) throws { guard let item = inventario[name] else { throw Errores.noExiste(nombre: nombre) } guard item.cantidad &gt; 0 else { throw Errores.fueraDeStock } item.price } De esta forma data Errores = FueraDeStock | NoExiste String buscar :: Inventario -&gt; String -&gt; Maybe Item buscar = (...) precio :: String -&gt; Either Errores Int precio nombre = do item &lt;- maybe (Left (NoExiste nombre)) Right itemEncontrado -- (1) when (cantidad item &gt; 0) (Left FueraDeStock) return precio item where itemEncontrado :: Maybe Item itemEncontrado = buscar inventario nombre La idea de la función maybe es poder extraer el valor de un Maybe (algo que puede o no estar). En el caso de que pueda fallar, devolveremos un Left (recordemos, representaría como lanzar una excepción), y en el caso que hubiese un Item, devolveremos un Right. De esta forma, no ejecutaremos el return hasta que no pasen las dos condiciones anteriores. Getter y Setter Por último, quiero tocar algo de modelado, y la parte de lo que menos quiero escribir, porque es la que más se separa del paradigma; pero no obstante puedo ver cómo alguien puede estar tentado a utilizar herramientas de modelado de paradigmas que ya conoce, y pensar en un record es parecido a un objeto. Pero si así fuera… donde ponemos los métodos de este objeto?! (Sin entrar en el mundo de lens). No voy a objetar (🤭) porque se que yo lo hice durante mucho tiempo, así que mientras que sepamos que hay tela para cortar, por ahora puedo vivir con que pensemos que son objetos. class Point { public int edad; } podríamos escribirlo así: data Persona = Persona { edad :: Int } Y tendremos gratis la función edad :: Persona -&gt; Int que “saca” la edad de una persona. Cual un getter, y la construcción: cambiarEdad :: Int -&gt; Persona -&gt; Persona cambiarEdad nuevaEdad persona = persona { edad = nuevaEdad } Como un setter. Pero, como en OOP no estamos limitados a simplemente asignar el nuevo valor; podríamos hacer lo que queramos! cambiarEdad :: Int -&gt; Persona -&gt; Persona cambiarEdad nuevaEdad persona = persona { edad = nuevaEdad + 3 } Podemos encontrar un patrón recurrente, donde tengamos funciones que terminen con el tipo: foo :: … -&gt; Algo -&gt; Algo. Si recordamos el ejemplo de tarjetaValida, todas las funciones intermedias que teníamos eran del tipo: :: Int -&gt; Int, y el ejercicio al lector hubiera generado una función con el tipo: :: Char -&gt; Int -&gt; Int. Podemos pensar en toda esta familia de funciones como funciones que “alteran”. Además ahora ya sabemos cómo combinarlas! Por ejemplo, concatenar listas (++) :: [a] -&gt; [a] -&gt; [a] en donde toma una primera lista y una segunda, y las “altera” (recordando que en realidad lo que hace es devolver una nueva lista) o tomar los primeros n elementos (take :: Int -&gt; [a] -&gt; [a]). Hay muchísimas funciones como estas, y probablemente escribamos tantas de estas como “métodos” podrían tener nuestros objetos, si lo modelamos en OOP. class Persona(var edad: Int, var altura: Int) { fun crecer(años : Int) { this.edad += años this.altura += años*2 } } data Persona = Persona { edad :: Int, altura :: Int } crecer :: Int -&gt; Persona -&gt; Persona crecer años persona = Persona { edad = edad persona + años, altura = altura persona + (años * 2) } Fin Espero que con estas herramientas, el prospecto de programar en Haskell sea menos aterrorizador." />
<link rel="canonical" href="https://dev.to/florius/haskell-para-mentes-imperativas-4n7k" />
<meta property="og:url" content="https://dev.to/florius/haskell-para-mentes-imperativas-4n7k" />
<meta property="og:site_name" content="Florius’ Blog" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2020-12-03T00:00:00+00:00" />
<meta name="twitter:card" content="summary" />
<meta property="twitter:title" content="Haskell para mentes imperativas" />
<meta name="twitter:site" content="@FloriusWasTaken" />
<meta name="twitter:creator" content="@FloriusWasTaken" />
<script type="application/ld+json">
{"author":{"@type":"Person","name":"Joaquin 'Florius' Azcarate"},"description":"El post original se puede leer en mi dev.to. Browseando YouTube encontré una playlist con un nombre muy interesante: “Haskell for Imperative Programmers” en donde el autor Philipp Hagenlocher explica conceptos de Haskell en videos cortos, concisos, con varios ejemplos y hasta algunos ejercicios. Lo que me inspiró a pensar cómo podría aprender alguien que tiene raíces en un paradigma imperativo. Por suerte no tuve que usar mucho la imaginación, ya que yo comencé con lenguajes imperativos, y en mi trabajo utilizo mayoritariamente el paradigma de objetos. En este post quiero explorar algunas cosas que creo que me hubiesen servido para aprender Haskell. Teniendo una base en algún lenguaje imperativo, usar esta para programar en Haskell. Si crees que entras en esta categoría, continúa leyendo. Prefacio En este post haré uso de analogías y de patrones fuertemente asociados a la programación imperativa, de tal forma que la carga para aclimatarse al nuevo paradigma sea la menor posible, pero no considero esta la mejora forma de programar de forma funcional. Mi razonamiento es que: usando nuestro conocimiento previo ayude a comenzar a escalar la pendiente que es aprender un paradigma nuevo, y que esto a su vez dispare nuevas e interesantes investigaciones. Variables Veo muy comúnmente la cara de espanto cuando uno habla de un lenguaje, como Haskell, donde la inmutabilidad está por defecto. Prontamente surge la pregunta de “cómo puedo asignar una variable” o “como puedo cambiar el valor de un contador”. Recordemos que Haskell es un lenguaje de programación Turing completo, así que no es que no se pueda hacer, solo que hay que reconocer que hay diferentes formas de afrontar un problema. En Haskell, el símbolo = no representa una asignación, si no es más próximo a la idea matemática del = donde lo leemos (e interpretamos) como que algo es otra cosa. En un lenguaje imperativo x = 3 lo leemos como “asignamos el valor 3 a la variable x”, donde en un paradigma funcional, lo deberíamos interpretar como “x es 3”. x no puede cambiar. x simplemente es. Se que esta justificación suele no quitar el pavor. Tras indagar más a fondo, suelo descubrir que hay dos temas distintos (pero muy sobrelapados en los lenguajes imperativos): Ponerle nombre a algo “intermedio”. Por ejemplo, si uno está escribiendo un método, y ve que hay una operación que se repite dos veces, suele ser considerado una buena práctica extraer lo común a una “variable” y ponerle nombre. Por ejemplo, podríamos empezar con un método: Int foo(List&lt;Int&gt; xs) { if(xs.size() &gt; 3) return -1; else return xs.size(); } y luego refactorizar a algo como: Int foo(List&lt;Int&gt; xs) { Int tamaño = xs.size(); if(tamaño &gt; 3) return -1; else return tamaño; } En este acaso tamaño si bien es una “variable”, su intención no es variar en el contexto de la función. Es tan común y útil poder aseverar sobre qué cosas no cambian, que en otros lenguajes existe la idea que las “variables” puedan ser constantes (vaya oxímoron). Como const en JavaScript y PHP, val/varen Kotlin, variables en mayúsculas en Python o final en Java. Lectores atentos pueden reconocer un potencial problema en esta refactorización, en donde no podemos asegurar 100% que el método List::size() no cambia la lista, y que invocarlo 2 veces como en el código de “antes” podría no ser igual al código de “despues” en donde solo se invoca una vez. Dado que conocemos la semántica de List::size(), podemos descansar que no va a alterar la lista; pero a veces, por la naturaleza de la mutabilidad, esto lleva a problemas. Toda una categoría de problemas que simplemente no pueden ocurrir en un mundo inmutable 😉. Esto mismo podríamos lograr en Haskell con palabras reservadas como let … in o where. foo :: [Int] -&gt; Int foo xs = if length xs then -1 else length xs Y luego del refactor: foo :: [Int] -&gt; Int foo xs = let tamaño = length xs in if tamaño &gt; 3 then -1 else tamaño o foo :: [Int] -&gt; Int foo xs = if tamaño &gt; 3 then -1 else tamaño where tamaño = length xs Si bien hacen lo mismo, tienen sutiles diferencias a las entraré en detalle (pero si está aquí: Let vs. Where - HaskellWiki). Cosas que cambian El otro sabor de variables, es el de algo que cambia; y aquí, no tenemos suerte. No vamos a poder hacerlo. Pero eso no quita que podamos generar abstracciones para poder escribir algo que se parezca. Pero antes de hablar de cosas que cambian, primero necesitamos estar de acuerdo en algunas convenciones. Cosas como void bar(int* x){ *x += 4; } En donde una función altera el valor que se le pasa son el mal, y no poder hacerlo es un feature (Aunque me encanta la idea de Pure destination-passing style in Linear Haskell cuando se apalanca del maravilloso sistema de tipos). Algo mucho más sensible sería una función que tome el argumento y devuelva un nuevo número, resultado de la suma del argumento y 4. Pero no siempre es tan sencillo. A veces tenemos varias mutaciones encadenadas, o unas que dependen de otras; por lo que podemos aplicar este algoritmo mental: Cada vez que fuésemos a cambiar una variable, en realidad utilizaremos una nueva variable que sea el resultado del cambio, y de ahora en adelante, utilizar el nuevo nombre. Por ejemplo, con la nueva herramienta de let … in: def buzz (n) ret = n ret = ret % 3 ret = ret +2 ret = ret + 5 ret &gt; 3 end buzz n = let x0 = n x1 = x0 `mod` 3 x2 = x1 + 2 x3 = x2 + 5 In x3 &gt; 3 Si esta forma de escribir parece tediosa (lo es!), al final de la próxima sección volveremos sobre esto, pero todavía tenemos algo que podemos hacer. Revisemos qué es lo que es tan inconveniente: nombrar los pasos intermedios (x0 - x3) ¿Podemos no hacerlo?. De esta forma nos acercamos a un patrón muy común en funcional, en donde uno tiene funciones intermedias que toman un valor, y devuelven “el nuevo” valor. Podemos concatenar estas operaciones (que hablan de cambios, no de variables). Imaginemos el mismo ejemplo, pero vamos a re escribirlo en pequeñas funciones intermedias que cambien el valor. buzz n = let f0 x = x `mod` 3 f1 x = x + 2 f2 x = x + 5 f3 x = x &gt; 3 x0 = n x1 = f0 x0 x2 = f1 x1 x3 = f2 x2 In f3 x3 Lamentablemente como es un ejemplo tan sintético, los nombres de las funciones intermedias serán malos; pero espero que puedan imaginarse que estas funciones sean cosas como incrementarEdad, extraerDinero u otro nombre más cercano al dominio de lo que esten programando. Por ello voy a cambiar levemente el ejemplo para tener algo que sea más humanamente legible. numeroValidador x = x `mod` 3 normalizarValidador x = x + 2 migrarCoeficiente x = x + 5 esValido x = x &gt; 3 tarjetaValida n = x0 = numeroValidador n x1 = normalizarValidador x0 x2 = migrarCoeficiente x1 In esValido x2 Ahora podemos intentar pensar sobre nuestra tarjetaValida, donde lo que tiene que pasar es, en orden: Dado un número pasado como parámetro (n) Tomamos el número validador (x mod 3) Lo normalizamos (x + 2) Migramos el coeficiente (x + 5) Y chequeamos que sea válido (x &gt; 3) Probablemente todavía no sea evidente, pero ahora podemos hacer un refactor de “inline” en cada variable intermedia (x0 - x3). Empecemos con x3 e iremos ineline-ando de a una tarjetaValida n = x0 = n x1 = numeroValidador x0 x2 = normalizarValidador x1 In esValido (migrarCoeficiente x1) tarjetaValida n = x0 = n x1 = numeroValidador x0 In esValido (migrarCoeficiente (normalizarValidador x1)) tarjetaValida n = x0 = n esValido (migrarCoeficiente (normalizarValidador (numeroValidador x0))) tarjetaValida n = esValido (migrarCoeficiente (normalizarValidador (numeroValidador n))) Esto se parece mucho más a la descripción funcional de tarjetaValida, pero está escrito “al revés”. Por razones como esta existen combinadores como &amp;, donde hablando mal y pronto, éste es el operador de aplicación reversa. tarjetaValida n = n &amp; numeroValidador &amp; normalizarValidador &amp; migrarCoeficiente &amp; esValido Es interesante notar como todas nuestras funciones de “cambio” tienen la misma firma: :: Int -&gt; Int. De forma más genérica, son funciones que toman un valor de un tipo, y devuelven algo del mismo tipo. Aplicación parcial Con el código que tenemos hasta aquí; podríamos cambiarlo para que migrarCoeficiente no siempre sume 5, si no que pueda ser parametrizable por una letra. Sabiendo que hay una función que transforma una letra a un número ord :: Char -&gt; Int Podríamos cambiar migrarCoeficiente a: migrarCoeficiente :: Char -&gt; Int -&gt; Int migrarCoeficiente letra x = x + (ord caracter) Ahora nuestra tarjetaValida no sufre muchos cambios: tarjetaValida n = n &amp; numeroValidador &amp; normalizarValidador &amp; migrarCoeficiente &#39;f&#39; &amp; esValido Y eso fué gracias a la currificación de todas las funciones en Haskell! A veces Otro gran “hack” que nos permite la mutabilidad, es la de cambiar el valor, pero solo según un flujo de control. Algo como: def qux(n): ret = n if(ret % 3): ret = 10 return ret En donde asignamos una variable que según uno u otro flujo de control puede cambiar. Siempre podremos reescribir esto de forma inmutable. Por ejemplo qux n = if n `mod` 3 == 0 then 10 else n Interesante notar que necesitamos un else que “deje todo como estaba”, pues no podemos “no hacer nada” en esta forma de escribirlo. Monadas (No podía ser un post de Haskell, y no mencionar a las monadas) Una idea en la programación imperativa muy arraigada es que uno escribe una línea debajo de la otra, y esto hace que se ejecuten en ese orden. Tan arraigada que casi no se considera una decisión del lenguaje, pero lo es! Es una decisión de diseño, y una que en un paradigma funcional es fácil escaparse. Pero a veces, queremos ordenar una secuencia de cosas. Recordemos el ejemplo anterior de buz. Hay una monada (y probablemente miles de tutoriales de como implementarla) llamada “state” que representa una forma de secuenciar operaciones, e ir mutando un valor. Por lo que uno podría escribir algo mucho más parecido a la forma imperativa: -- |----- Va a ir mutando un Int -- v v- va a retornar un booleano buz :: State Int Bool buz = get &gt;&gt;= (\\ret -&gt; set (ret `mod` 3)) &gt;&gt; get &gt;&gt;= (\\ret -&gt; put (ret + 2)) &gt;&gt; get &gt;&gt;= (\\ret -&gt; set (ret + 5)) &gt;&gt; get &gt;&gt;= (\\ret -&gt; return (ret &gt; 3)) Cada ret en este caso solo existe dentro del lambda (todo lo que esté entre (\\ y )) Muchas veces se ven las monadas con el azúcar sintáctico de la notación do, que lo hace muy conveniente porque nos deja, como en un paradigma imperativo, escribir una línea debajo de la otra. Monadas Cont. Otra gran razón para implementar una secuencia de operaciones, es que estas puedan fallar. El fallo en cualquier renglón invalide toda la computación. Pensemos en métodos que podrían lanzar excepciones. Para esto también existe una monada! Y podríamos escribir algo como: func precio(itemConNombre nombre: String) throws { guard let item = inventario[name] else { throw Errores.noExiste(nombre: nombre) } guard item.cantidad &gt; 0 else { throw Errores.fueraDeStock } item.price } De esta forma data Errores = FueraDeStock | NoExiste String buscar :: Inventario -&gt; String -&gt; Maybe Item buscar = (...) precio :: String -&gt; Either Errores Int precio nombre = do item &lt;- maybe (Left (NoExiste nombre)) Right itemEncontrado -- (1) when (cantidad item &gt; 0) (Left FueraDeStock) return precio item where itemEncontrado :: Maybe Item itemEncontrado = buscar inventario nombre La idea de la función maybe es poder extraer el valor de un Maybe (algo que puede o no estar). En el caso de que pueda fallar, devolveremos un Left (recordemos, representaría como lanzar una excepción), y en el caso que hubiese un Item, devolveremos un Right. De esta forma, no ejecutaremos el return hasta que no pasen las dos condiciones anteriores. Getter y Setter Por último, quiero tocar algo de modelado, y la parte de lo que menos quiero escribir, porque es la que más se separa del paradigma; pero no obstante puedo ver cómo alguien puede estar tentado a utilizar herramientas de modelado de paradigmas que ya conoce, y pensar en un record es parecido a un objeto. Pero si así fuera… donde ponemos los métodos de este objeto?! (Sin entrar en el mundo de lens). No voy a objetar (🤭) porque se que yo lo hice durante mucho tiempo, así que mientras que sepamos que hay tela para cortar, por ahora puedo vivir con que pensemos que son objetos. class Point { public int edad; } podríamos escribirlo así: data Persona = Persona { edad :: Int } Y tendremos gratis la función edad :: Persona -&gt; Int que “saca” la edad de una persona. Cual un getter, y la construcción: cambiarEdad :: Int -&gt; Persona -&gt; Persona cambiarEdad nuevaEdad persona = persona { edad = nuevaEdad } Como un setter. Pero, como en OOP no estamos limitados a simplemente asignar el nuevo valor; podríamos hacer lo que queramos! cambiarEdad :: Int -&gt; Persona -&gt; Persona cambiarEdad nuevaEdad persona = persona { edad = nuevaEdad + 3 } Podemos encontrar un patrón recurrente, donde tengamos funciones que terminen con el tipo: foo :: … -&gt; Algo -&gt; Algo. Si recordamos el ejemplo de tarjetaValida, todas las funciones intermedias que teníamos eran del tipo: :: Int -&gt; Int, y el ejercicio al lector hubiera generado una función con el tipo: :: Char -&gt; Int -&gt; Int. Podemos pensar en toda esta familia de funciones como funciones que “alteran”. Además ahora ya sabemos cómo combinarlas! Por ejemplo, concatenar listas (++) :: [a] -&gt; [a] -&gt; [a] en donde toma una primera lista y una segunda, y las “altera” (recordando que en realidad lo que hace es devolver una nueva lista) o tomar los primeros n elementos (take :: Int -&gt; [a] -&gt; [a]). Hay muchísimas funciones como estas, y probablemente escribamos tantas de estas como “métodos” podrían tener nuestros objetos, si lo modelamos en OOP. class Persona(var edad: Int, var altura: Int) { fun crecer(años : Int) { this.edad += años this.altura += años*2 } } data Persona = Persona { edad :: Int, altura :: Int } crecer :: Int -&gt; Persona -&gt; Persona crecer años persona = Persona { edad = edad persona + años, altura = altura persona + (años * 2) } Fin Espero que con estas herramientas, el prospecto de programar en Haskell sea menos aterrorizador.","url":"https://dev.to/florius/haskell-para-mentes-imperativas-4n7k","@type":"BlogPosting","headline":"Haskell para mentes imperativas","dateModified":"2020-12-03T00:00:00+00:00","datePublished":"2020-12-03T00:00:00+00:00","mainEntityOfPage":{"@type":"WebPage","@id":"https://dev.to/florius/haskell-para-mentes-imperativas-4n7k"},"@context":"https://schema.org"}</script>
<!-- End Jekyll SEO tag -->

    <!-- Custom CSS -->
    <link rel="stylesheet" href="/css/pixyll.css?202105131826" type="text/css">

    <!-- Fonts -->
    <link href="//fonts.googleapis.com/css?family=Karla|Montserrat&amp;display=swap" rel="stylesheet">
    
    <script src="//kit.fontawesome.com/88434a0a24.js" crossorigin="anonymous" async></script>
    

    <!-- MathJax -->
    

    <!-- Verifications -->
    
    

    <!-- Icons -->
    <link rel="shortcut icon" href="/favicon.ico">
    <link rel="apple-touch-icon" sizes="180x180" href="/assets/ad1057-88b568df243fbbe29828fd65ea54684bab0676479e6f2272724dad3dfa0123e14fcfdde7cfa544ab6c3ceed0e14e50821e2e7f69dd0170a5e4110d21f3f21f22.png" />
    <link rel="icon" type="image/png" sizes="32x32" href="/assets/03f085-63c7756137399d92bee1ae085badf266ff0e42fb96c400dc7a4d34b1d36b8d5b1cbda2735b84d342a8108a8306d43a8447dfab15fb55e3fc62192074ca1348e5.png" />
    <link rel="icon" type="image/png" sizes="16x16" href="/assets/7b553b-86f42c54f3e747569d8337b4b89053e9ad1bc63e388e685738a2461f946d98673618660ab7cb0c9dc0c8aa9fbf440657dedcaab36de05326269df1bfb6e8fe82.png"/>

    <meta name="theme-color" content="#000000">

    
</head>

<body class="site">
	

  <div class="site-wrap">
    <header class="site-header px2 px-responsive">
  <div class="mt2 wrap">
    <div class="measure">
      <a href="/" class="site-title">Florius’ Blog</a>
      <nav class="site-nav">
        



    
    
    
    

    

    
    
    
    
        <a class="nav-link" href="/about/">About</a>
    

    

    
    
    
    
        <a class="nav-link" href="/categories/">Categories</a>
    

    

    
    
    
    

    

    
    
    
    

    

    
    
    
    

    

    
    
    
    

    

    
    
    
    

    

    
    
    
    

    

    
    
    
    

    

    
    
    
    

    

    
    
    
    

    


      </nav>
      <div class="clearfix"></div>
      
        <div class="social-icons">
  <div class="social-icons-right">
    
      <a class="fa fa-github" href="https://github.com/jazcarate"></a>
    
    
      <a class="fa fa-gitlab" href="https://gitlab.com/jazcarate"></a>
    
    
    
    
    
    
    
    
    
    
      <a class="fa fa-envelope" href="mailto:j@florius.com.ar"></a>
    
    
      <a class="fa fa-linkedin" href="https://www.linkedin.com/in/joaquin-azcarate"></a>
    
    
    <a class="fab fa-dev" href="https://dev.to/florius"></a>
    
    
    
    
    
  </div>
  <div class="right">
    
    
    
  </div>
</div>
<div class="clearfix"></div>

      
    </div>
  </div>
</header>


    <div class="post p2 p-responsive wrap animated fade-in-down" role="main">
      <div class="measure">
        


<div class="post-header mb2">
  <h1>Haskell para mentes imperativas</h1>
  <span class="post-meta">Dec 3, 2020</span><br>
  
  <span class="post-meta small read-time">
  
    13 minute read
  
  </span>
</div>

<article class="post-content">
  <p><em>El post original se puede leer en mi <a href="https://dev.to/florius/haskell-para-mentes-imperativas-4n7k">dev.to</a>.</em></p>

<p>Browseando YouTube encontré una playlist con un nombre muy interesante: “<a href="https://www.youtube.com/watch?v=Vgu82wiiZ90&amp;list=PLe7Ei6viL6jGp1Rfu0dil1JH1SHk9bgDV">Haskell for Imperative Programmers</a>” en donde el autor Philipp Hagenlocher explica conceptos de Haskell en videos cortos, concisos, con varios ejemplos y hasta algunos ejercicios. Lo que me inspiró a pensar cómo podría aprender alguien que tiene raíces en un paradigma imperativo. Por suerte no tuve que usar mucho la imaginación, ya que yo comencé con lenguajes imperativos, y en mi trabajo utilizo mayoritariamente el paradigma de objetos.</p>

<p>En este post quiero explorar algunas cosas que creo que me hubiesen servido para aprender Haskell. Teniendo una base en algún lenguaje imperativo, usar esta para programar en Haskell.</p>

<p>Si crees que entras en esta categoría, continúa leyendo.</p>

<h3 id="prefacio">Prefacio</h3>
<p>En este post haré uso de analogías y de patrones fuertemente asociados a la programación imperativa, de tal forma que la carga para aclimatarse al nuevo paradigma sea la menor posible, pero no considero esta la mejora forma de programar de forma funcional. Mi razonamiento es que: usando nuestro conocimiento previo ayude a comenzar a escalar la pendiente que es aprender un paradigma nuevo, y que esto a su vez dispare nuevas e interesantes investigaciones.</p>

<h2 id="variables">Variables</h2>

<p>Veo muy comúnmente la cara de espanto cuando uno habla de un lenguaje, como Haskell, donde la inmutabilidad está por defecto. Prontamente surge la pregunta de “cómo puedo asignar una variable” o “como puedo cambiar el valor de un contador”.
Recordemos que Haskell es un lenguaje de programación <a href="https://es.wikipedia.org/wiki/Turing_completo">Turing completo</a>, así que no es que <em>no se pueda</em> hacer, solo que hay que reconocer  que hay diferentes formas de afrontar un problema.</p>

<p>En Haskell, el símbolo <code class="language-plaintext highlighter-rouge">=</code> no representa una asignación, si no es más próximo a la idea matemática del <code class="language-plaintext highlighter-rouge">=</code> donde lo leemos (e interpretamos) como que algo <strong>es</strong> otra cosa.</p>

<p>En un lenguaje imperativo <code class="language-plaintext highlighter-rouge">x = 3</code> lo leemos como “asignamos el valor <code class="language-plaintext highlighter-rouge">3</code> a la variable <code class="language-plaintext highlighter-rouge">x</code>”, donde en un paradigma funcional, lo deberíamos interpretar como “<code class="language-plaintext highlighter-rouge">x</code> <em>es</em> 3”. <code class="language-plaintext highlighter-rouge">x</code> no puede cambiar. <code class="language-plaintext highlighter-rouge">x</code> simplemente <em>es</em>.</p>

<p>Se que esta justificación suele no quitar el pavor. Tras indagar más a fondo, suelo descubrir que hay dos temas distintos (pero muy  sobrelapados en los lenguajes imperativos):</p>

<p>Ponerle nombre a algo “intermedio”. Por ejemplo, si uno está escribiendo un método, y ve que hay una operación que se repite dos veces, suele ser considerado una buena práctica extraer lo común a una “variable” y ponerle nombre. Por ejemplo, podríamos empezar con un método:</p>

<figure class="highlight"><pre><code class="language-java" data-lang="java"><span class="nc">Int</span> <span class="nf">foo</span><span class="o">(</span><span class="nc">List</span><span class="o">&lt;</span><span class="nc">Int</span><span class="o">&gt;</span> <span class="n">xs</span><span class="o">)</span> <span class="o">{</span>
  <span class="k">if</span><span class="o">(</span><span class="n">xs</span><span class="o">.</span><span class="na">size</span><span class="o">()</span> <span class="o">&gt;</span> <span class="mi">3</span><span class="o">)</span>
    <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="o">;</span>
  <span class="k">else</span>
    <span class="k">return</span> <span class="n">xs</span><span class="o">.</span><span class="na">size</span><span class="o">();</span>
<span class="o">}</span></code></pre></figure>

<p>y luego refactorizar a algo como:</p>

<figure class="highlight"><pre><code class="language-java" data-lang="java"><span class="nc">Int</span> <span class="nf">foo</span><span class="o">(</span><span class="nc">List</span><span class="o">&lt;</span><span class="nc">Int</span><span class="o">&gt;</span> <span class="n">xs</span><span class="o">)</span> <span class="o">{</span>
  <span class="nc">Int</span> <span class="n">tamaño</span> <span class="o">=</span> <span class="n">xs</span><span class="o">.</span><span class="na">size</span><span class="o">();</span>
  <span class="k">if</span><span class="o">(</span><span class="n">tamaño</span> <span class="o">&gt;</span> <span class="mi">3</span><span class="o">)</span>
    <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="o">;</span>
  <span class="k">else</span>
    <span class="k">return</span> <span class="n">tamaño</span><span class="o">;</span>
<span class="o">}</span></code></pre></figure>

<p>En este acaso <code class="language-plaintext highlighter-rouge">tamaño</code> si bien es una “variable”, su intención no es variar en el contexto de la función. Es tan común y útil poder aseverar sobre qué cosas no cambian, que en otros lenguajes existe la idea que las “variables” puedan ser constantes (vaya oxímoron). Como <code class="language-plaintext highlighter-rouge">const</code> en JavaScript y PHP, <code class="language-plaintext highlighter-rouge">val</code>/<code class="language-plaintext highlighter-rouge">var</code>en Kotlin, variables en mayúsculas en Python o <code class="language-plaintext highlighter-rouge">final</code> en Java.</p>

<p>Lectores atentos pueden reconocer un potencial problema en esta refactorización, en donde no podemos asegurar 100% que el método <code class="language-plaintext highlighter-rouge">List::size()</code> no cambia la lista, y que invocarlo 2 veces como en el código de “antes” podría no ser igual al código de “despues” en donde solo se invoca una vez. Dado que conocemos la semántica de <code class="language-plaintext highlighter-rouge">List::size()</code>, podemos descansar que no va a alterar la lista; pero a veces, por la naturaleza de la mutabilidad, esto lleva a problemas. Toda una categoría de problemas que simplemente no pueden ocurrir en un mundo inmutable 😉.</p>

<p>Esto mismo podríamos lograr en Haskell con palabras reservadas como <code class="language-plaintext highlighter-rouge">let … in</code> o <code class="language-plaintext highlighter-rouge">where</code>.</p>

<figure class="highlight"><pre><code class="language-haskell" data-lang="haskell"><span class="n">foo</span> <span class="o">::</span> <span class="p">[</span><span class="kt">Int</span><span class="p">]</span> <span class="o">-&gt;</span> <span class="kt">Int</span>
<span class="n">foo</span> <span class="n">xs</span> <span class="o">=</span> <span class="kr">if</span> <span class="n">length</span> <span class="n">xs</span> <span class="kr">then</span>
         <span class="o">-</span><span class="mi">1</span>
       <span class="kr">else</span>
         <span class="n">length</span> <span class="n">xs</span></code></pre></figure>

<p>Y luego del refactor:</p>

<figure class="highlight"><pre><code class="language-haskell" data-lang="haskell"><span class="n">foo</span> <span class="o">::</span> <span class="p">[</span><span class="kt">Int</span><span class="p">]</span> <span class="o">-&gt;</span> <span class="kt">Int</span>
<span class="n">foo</span> <span class="n">xs</span> <span class="o">=</span>
   <span class="kr">let</span> <span class="n">tama</span><span class="err">ñ</span><span class="n">o</span> <span class="o">=</span> <span class="n">length</span> <span class="n">xs</span>
   <span class="kr">in</span> <span class="kr">if</span> <span class="n">tama</span><span class="err">ñ</span><span class="n">o</span> <span class="o">&gt;</span> <span class="mi">3</span> <span class="kr">then</span>
         <span class="o">-</span><span class="mi">1</span>
       <span class="kr">else</span>
         <span class="n">tama</span><span class="err">ñ</span><span class="n">o</span></code></pre></figure>

<p>o</p>

<figure class="highlight"><pre><code class="language-haskell" data-lang="haskell"><span class="n">foo</span> <span class="o">::</span> <span class="p">[</span><span class="kt">Int</span><span class="p">]</span> <span class="o">-&gt;</span> <span class="kt">Int</span>
<span class="n">foo</span> <span class="n">xs</span> <span class="o">=</span> <span class="kr">if</span> <span class="n">tama</span><span class="err">ñ</span><span class="n">o</span> <span class="o">&gt;</span> <span class="mi">3</span> <span class="kr">then</span>
         <span class="o">-</span><span class="mi">1</span>
       <span class="kr">else</span>
         <span class="n">tama</span><span class="err">ñ</span><span class="n">o</span>
   <span class="kr">where</span> <span class="n">tama</span><span class="err">ñ</span><span class="n">o</span> <span class="o">=</span> <span class="n">length</span> <span class="n">xs</span></code></pre></figure>

<p>Si bien hacen lo mismo, tienen sutiles diferencias a las entraré en detalle (pero si está aquí: <a href="https://wiki.haskell.org/Let_vs._Where">Let vs. Where - HaskellWiki</a>).</p>

<h2 id="cosas-que-cambian">Cosas que cambian</h2>

<p>El otro <em>sabor</em> de variables, es el de algo que cambia; y aquí, no tenemos suerte. No vamos a poder hacerlo. Pero eso no quita que podamos generar abstracciones para poder escribir algo que <em>se parezca</em>.</p>

<p>Pero antes de hablar de cosas que cambian, primero necesitamos estar de acuerdo en algunas convenciones. Cosas como</p>

<figure class="highlight"><pre><code class="language-c" data-lang="c"><span class="kt">void</span> <span class="nf">bar</span><span class="p">(</span><span class="kt">int</span><span class="o">*</span> <span class="n">x</span><span class="p">){</span>
    <span class="o">*</span><span class="n">x</span> <span class="o">+=</span> <span class="mi">4</span><span class="p">;</span>
<span class="p">}</span></code></pre></figure>

<p>En donde una función altera el valor que se le pasa son <em>el mal</em>, y no poder hacerlo es un <em>feature</em> (Aunque me encanta la idea de <a href="https://www.tweag.io/blog/2020-11-11-linear-dps/">Pure destination-passing style in Linear Haskell</a> cuando se apalanca del maravilloso sistema de tipos).</p>

<p>Algo mucho más sensible sería una función que tome el argumento y devuelva un nuevo número, resultado de la suma del argumento y 4.</p>

<p>Pero no siempre es tan sencillo. A veces tenemos varias mutaciones encadenadas, o unas que dependen de otras; por lo que podemos aplicar este algoritmo mental:
Cada vez que fuésemos a cambiar una variable, en realidad utilizaremos una nueva variable que sea el resultado del cambio, y de ahora en adelante, utilizar el nuevo nombre.</p>

<p>Por ejemplo, con la nueva herramienta de <code class="language-plaintext highlighter-rouge">let … in</code>:</p>

<figure class="highlight"><pre><code class="language-ruby" data-lang="ruby"><span class="k">def</span> <span class="nf">buzz</span> <span class="p">(</span><span class="n">n</span><span class="p">)</span>
  <span class="n">ret</span> <span class="o">=</span> <span class="n">n</span>
  <span class="n">ret</span> <span class="o">=</span> <span class="n">ret</span> <span class="o">%</span> <span class="mi">3</span>
  <span class="n">ret</span> <span class="o">=</span> <span class="n">ret</span> <span class="o">+</span><span class="mi">2</span>
  <span class="n">ret</span> <span class="o">=</span> <span class="n">ret</span> <span class="o">+</span> <span class="mi">5</span>
  <span class="n">ret</span> <span class="o">&gt;</span> <span class="mi">3</span>
<span class="k">end</span></code></pre></figure>

<figure class="highlight"><pre><code class="language-haskell" data-lang="haskell"><span class="n">buzz</span> <span class="n">n</span> <span class="o">=</span>
  <span class="kr">let</span> 
       <span class="n">x0</span> <span class="o">=</span> <span class="n">n</span>
       <span class="n">x1</span> <span class="o">=</span> <span class="n">x0</span> <span class="p">`</span><span class="n">mod</span><span class="p">`</span> <span class="mi">3</span>
       <span class="n">x2</span> <span class="o">=</span> <span class="n">x1</span> <span class="o">+</span> <span class="mi">2</span>
       <span class="n">x3</span> <span class="o">=</span> <span class="n">x2</span> <span class="o">+</span> <span class="mi">5</span>
  <span class="kt">In</span> <span class="n">x3</span> <span class="o">&gt;</span> <span class="mi">3</span></code></pre></figure>

<p>Si esta forma de escribir parece tediosa (lo es!), al final de la próxima sección volveremos sobre esto, pero todavía tenemos algo que podemos hacer. Revisemos qué es lo que es tan inconveniente: nombrar los pasos intermedios (<code class="language-plaintext highlighter-rouge">x0 - x3</code>) ¿Podemos no hacerlo?.</p>

<p>De esta forma nos acercamos a un patrón muy común en funcional, en donde uno tiene funciones intermedias que toman un valor, y devuelven “el nuevo” valor. Podemos concatenar estas operaciones (que hablan de cambios, no de variables).</p>

<p>Imaginemos el mismo ejemplo, pero vamos a re escribirlo en pequeñas funciones intermedias que cambien el valor.</p>

<figure class="highlight"><pre><code class="language-haskell" data-lang="haskell"><span class="n">buzz</span> <span class="n">n</span> <span class="o">=</span>
  <span class="kr">let</span> <span class="n">f0</span> <span class="n">x</span> <span class="o">=</span> <span class="n">x</span> <span class="p">`</span><span class="n">mod</span><span class="p">`</span> <span class="mi">3</span>
       <span class="n">f1</span> <span class="n">x</span> <span class="o">=</span> <span class="n">x</span> <span class="o">+</span> <span class="mi">2</span>
       <span class="n">f2</span> <span class="n">x</span> <span class="o">=</span> <span class="n">x</span> <span class="o">+</span> <span class="mi">5</span>
       <span class="n">f3</span> <span class="n">x</span> <span class="o">=</span> <span class="n">x</span> <span class="o">&gt;</span> <span class="mi">3</span>
      
       <span class="n">x0</span> <span class="o">=</span> <span class="n">n</span>
       <span class="n">x1</span> <span class="o">=</span> <span class="n">f0</span> <span class="n">x0</span>
       <span class="n">x2</span> <span class="o">=</span> <span class="n">f1</span> <span class="n">x1</span>
       <span class="n">x3</span> <span class="o">=</span> <span class="n">f2</span> <span class="n">x2</span>
  <span class="kt">In</span> <span class="n">f3</span> <span class="n">x3</span></code></pre></figure>

<p>Lamentablemente como es un ejemplo tan sintético, los nombres de las funciones intermedias serán malos; pero espero que puedan imaginarse que estas funciones sean cosas como <code class="language-plaintext highlighter-rouge">incrementarEdad</code>, <code class="language-plaintext highlighter-rouge">extraerDinero</code> u otro nombre más cercano al dominio de lo que esten programando.</p>

<p>Por ello voy a cambiar levemente el ejemplo para tener algo que sea más humanamente legible.</p>

<figure class="highlight"><pre><code class="language-haskell" data-lang="haskell"><span class="n">numeroValidador</span> <span class="n">x</span> <span class="o">=</span> <span class="n">x</span> <span class="p">`</span><span class="n">mod</span><span class="p">`</span> <span class="mi">3</span>
<span class="n">normalizarValidador</span> <span class="n">x</span> <span class="o">=</span> <span class="n">x</span> <span class="o">+</span> <span class="mi">2</span>
<span class="n">migrarCoeficiente</span> <span class="n">x</span> <span class="o">=</span> <span class="n">x</span> <span class="o">+</span> <span class="mi">5</span>
<span class="n">esValido</span> <span class="n">x</span> <span class="o">=</span> <span class="n">x</span> <span class="o">&gt;</span> <span class="mi">3</span>

<span class="n">tarjetaValida</span> <span class="n">n</span> <span class="o">=</span>
       <span class="n">x0</span> <span class="o">=</span> <span class="n">numeroValidador</span> <span class="n">n</span>
       <span class="n">x1</span> <span class="o">=</span> <span class="n">normalizarValidador</span> <span class="n">x0</span>
       <span class="n">x2</span> <span class="o">=</span> <span class="n">migrarCoeficiente</span> <span class="n">x1</span>
  <span class="kt">In</span> <span class="n">esValido</span> <span class="n">x2</span></code></pre></figure>

<p>Ahora podemos intentar pensar sobre nuestra <code class="language-plaintext highlighter-rouge">tarjetaValida</code>, donde lo que tiene que pasar es, en orden:</p>

<ol>
  <li>Dado un número pasado como parámetro (<code class="language-plaintext highlighter-rouge">n</code>)</li>
  <li>Tomamos el número validador (<code class="language-plaintext highlighter-rouge">x mod 3</code>)</li>
  <li>Lo normalizamos (<code class="language-plaintext highlighter-rouge">x + 2</code>)</li>
  <li>Migramos el coeficiente (<code class="language-plaintext highlighter-rouge">x + 5</code>)</li>
  <li>Y chequeamos que sea válido (<code class="language-plaintext highlighter-rouge">x &gt; 3</code>)</li>
</ol>

<p>Probablemente todavía no sea evidente, pero ahora podemos hacer un refactor de “inline” en cada variable intermedia (<code class="language-plaintext highlighter-rouge">x0 - x3</code>). Empecemos con <code class="language-plaintext highlighter-rouge">x3</code> e iremos ineline-ando de a una</p>

<figure class="highlight"><pre><code class="language-haskell" data-lang="haskell"><span class="n">tarjetaValida</span> <span class="n">n</span> <span class="o">=</span>
       <span class="n">x0</span> <span class="o">=</span> <span class="n">n</span>
       <span class="n">x1</span> <span class="o">=</span> <span class="n">numeroValidador</span> <span class="n">x0</span>
       <span class="n">x2</span> <span class="o">=</span> <span class="n">normalizarValidador</span> <span class="n">x1</span>
  <span class="kt">In</span> <span class="n">esValido</span> <span class="p">(</span><span class="n">migrarCoeficiente</span>  <span class="n">x1</span><span class="p">)</span></code></pre></figure>

<figure class="highlight"><pre><code class="language-haskell" data-lang="haskell"><span class="n">tarjetaValida</span> <span class="n">n</span> <span class="o">=</span>
       <span class="n">x0</span> <span class="o">=</span> <span class="n">n</span>
       <span class="n">x1</span> <span class="o">=</span> <span class="n">numeroValidador</span> <span class="n">x0</span>
  <span class="kt">In</span> <span class="n">esValido</span> <span class="p">(</span><span class="n">migrarCoeficiente</span>  <span class="p">(</span><span class="n">normalizarValidador</span>  <span class="n">x1</span><span class="p">))</span></code></pre></figure>

<figure class="highlight"><pre><code class="language-haskell" data-lang="haskell"><span class="n">tarjetaValida</span> <span class="n">n</span> <span class="o">=</span>
       <span class="n">x0</span> <span class="o">=</span> <span class="n">n</span>
  <span class="n">esValido</span>  <span class="p">(</span><span class="n">migrarCoeficiente</span> <span class="p">(</span><span class="n">normalizarValidador</span> <span class="p">(</span><span class="n">numeroValidador</span> <span class="n">x0</span><span class="p">)))</span></code></pre></figure>

<figure class="highlight"><pre><code class="language-haskell" data-lang="haskell"><span class="n">tarjetaValida</span> <span class="n">n</span> <span class="o">=</span>
  <span class="n">esValido</span>  <span class="p">(</span><span class="n">migrarCoeficiente</span> <span class="p">(</span><span class="n">normalizarValidador</span> <span class="p">(</span><span class="n">numeroValidador</span> <span class="n">n</span><span class="p">)))</span></code></pre></figure>

<p>Esto se parece mucho más a la descripción funcional de <code class="language-plaintext highlighter-rouge">tarjetaValida</code>, pero está escrito “al revés”. Por razones como esta existen <a href="https://hackage.haskell.org/package/base-4.14.0.0/docs/Data-Function.html#v:-38-">combinadores como <code class="language-plaintext highlighter-rouge">&amp;</code></a>, donde hablando mal y pronto, éste es el operador de <em>aplicación reversa</em>.</p>

<figure class="highlight"><pre><code class="language-haskell" data-lang="haskell"><span class="n">tarjetaValida</span> <span class="n">n</span> <span class="o">=</span>
  <span class="n">n</span> <span class="o">&amp;</span>
  <span class="n">numeroValidador</span> <span class="o">&amp;</span>
  <span class="n">normalizarValidador</span> <span class="o">&amp;</span>
  <span class="n">migrarCoeficiente</span> <span class="o">&amp;</span>
  <span class="n">esValido</span></code></pre></figure>

<p>Es interesante notar como todas nuestras funciones de “cambio” tienen la misma firma: <code class="language-plaintext highlighter-rouge">:: Int -&gt; Int</code>. De forma más genérica, son funciones que toman un valor de un tipo, y <em>devuelven</em> algo del mismo tipo.</p>

<h3 id="aplicación-parcial">Aplicación parcial</h3>
<p>Con el código que tenemos hasta aquí; podríamos cambiarlo para que <code class="language-plaintext highlighter-rouge">migrarCoeficiente</code> no siempre sume 5, si no que pueda ser parametrizable por una letra.
Sabiendo que hay una función que transforma una letra a un número <a href="https://hackage.haskell.org/package/base-4.14.0.0/docs/Data-Char.html#v:ord"><code class="language-plaintext highlighter-rouge">ord :: Char -&gt; Int</code></a> 
Podríamos cambiar <code class="language-plaintext highlighter-rouge">migrarCoeficiente</code> a:</p>

<figure class="highlight"><pre><code class="language-haskell" data-lang="haskell"><span class="n">migrarCoeficiente</span> <span class="o">::</span> <span class="kt">Char</span> <span class="o">-&gt;</span> <span class="kt">Int</span> <span class="o">-&gt;</span> <span class="kt">Int</span>
<span class="n">migrarCoeficiente</span> <span class="n">letra</span> <span class="n">x</span> <span class="o">=</span> <span class="n">x</span> <span class="o">+</span> <span class="p">(</span><span class="n">ord</span> <span class="n">caracter</span><span class="p">)</span></code></pre></figure>

<p>Ahora nuestra <code class="language-plaintext highlighter-rouge">tarjetaValida</code> no sufre muchos cambios:</p>

<figure class="highlight"><pre><code class="language-haskell" data-lang="haskell"><span class="n">tarjetaValida</span> <span class="n">n</span> <span class="o">=</span>
  <span class="n">n</span> <span class="o">&amp;</span>
  <span class="n">numeroValidador</span> <span class="o">&amp;</span>
  <span class="n">normalizarValidador</span> <span class="o">&amp;</span>
  <span class="n">migrarCoeficiente</span> <span class="sc">'f'</span> <span class="o">&amp;</span>
  <span class="n">esValido</span></code></pre></figure>

<p>Y eso fué gracias a <a href="http://aprendehaskell.es/content/OrdenSuperior.html">la currificación</a> de todas las funciones en Haskell!</p>

<h3 id="a-veces">A veces</h3>

<p>Otro gran “hack” que nos permite la mutabilidad, es la de cambiar el valor, pero solo según un flujo de control. Algo como:</p>

<figure class="highlight"><pre><code class="language-python" data-lang="python"><span class="k">def</span> <span class="nf">qux</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
  <span class="n">ret</span> <span class="o">=</span> <span class="n">n</span>
  <span class="k">if</span><span class="p">(</span><span class="n">ret</span> <span class="o">%</span> <span class="mi">3</span><span class="p">):</span>
    <span class="n">ret</span> <span class="o">=</span> <span class="mi">10</span>
  <span class="k">return</span> <span class="n">ret</span></code></pre></figure>

<p>En donde asignamos una variable que según uno u otro flujo de control puede cambiar. Siempre podremos reescribir esto de forma inmutable. Por ejemplo</p>

<figure class="highlight"><pre><code class="language-haskell" data-lang="haskell"><span class="n">qux</span> <span class="n">n</span> <span class="o">=</span> <span class="kr">if</span> <span class="n">n</span> <span class="p">`</span><span class="n">mod</span><span class="p">`</span> <span class="mi">3</span> <span class="o">==</span> <span class="mi">0</span> <span class="kr">then</span> <span class="mi">10</span> <span class="kr">else</span> <span class="n">n</span></code></pre></figure>

<p>Interesante notar que necesitamos un <code class="language-plaintext highlighter-rouge">else</code> que “deje todo como estaba”, pues no podemos “no hacer nada” en esta forma de escribirlo.</p>

<h2 id="monadas">Monadas</h2>

<p><em>(No podía ser un post de Haskell, y no mencionar a las monadas)</em></p>

<p>Una idea en la programación imperativa muy arraigada es que uno escribe una línea debajo de la otra, y esto hace que se ejecuten en ese orden.
Tan arraigada que casi no se considera una decisión del lenguaje, pero lo es! Es una decisión de diseño, y una que en un paradigma funcional es fácil escaparse.</p>

<p>Pero a veces, queremos ordenar una secuencia de cosas. Recordemos el ejemplo anterior de <code class="language-plaintext highlighter-rouge">buz</code>. Hay una monada (y probablemente <a href="http://aprendehaskell.es/content/MasMonadas.html">miles de</a> <a href="https://gist.github.com/sdiehl/8d991a718f7a9c80f54b">tutoriales de</a> <a href="https://wiki.haskell.org/State_Monad">como</a> <a href="https://mmhaskell.com/monads/state">implementarla</a>) llamada “state” que representa una forma de secuenciar operaciones, e ir mutando un valor. Por lo que uno podría escribir algo mucho más parecido a la forma imperativa:</p>

<figure class="highlight"><pre><code class="language-haskell" data-lang="haskell"><span class="cd">--            |----- Va a ir mutando un Int
</span>
<span class="c1">--            v   v- va a retornar un booleano
</span>
<span class="n">buz</span> <span class="o">::</span> <span class="kt">State</span> <span class="kt">Int</span> <span class="kt">Bool</span>
<span class="n">buz</span> <span class="o">=</span>
  <span class="n">get</span> <span class="o">&gt;&gt;=</span> <span class="p">(</span><span class="nf">\</span><span class="n">ret</span> <span class="o">-&gt;</span> <span class="n">set</span> <span class="p">(</span><span class="n">ret</span> <span class="p">`</span><span class="n">mod</span><span class="p">`</span> <span class="mi">3</span><span class="p">))</span> <span class="o">&gt;&gt;</span>
  <span class="n">get</span> <span class="o">&gt;&gt;=</span> <span class="p">(</span><span class="nf">\</span><span class="n">ret</span> <span class="o">-&gt;</span> <span class="n">put</span> <span class="p">(</span><span class="n">ret</span> <span class="o">+</span> <span class="mi">2</span><span class="p">))</span> <span class="o">&gt;&gt;</span>
  <span class="n">get</span> <span class="o">&gt;&gt;=</span> <span class="p">(</span><span class="nf">\</span><span class="n">ret</span> <span class="o">-&gt;</span> <span class="n">set</span> <span class="p">(</span><span class="n">ret</span> <span class="o">+</span> <span class="mi">5</span><span class="p">))</span> <span class="o">&gt;&gt;</span>
  <span class="n">get</span> <span class="o">&gt;&gt;=</span> <span class="p">(</span><span class="nf">\</span><span class="n">ret</span> <span class="o">-&gt;</span> <span class="n">return</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&gt;</span> <span class="mi">3</span><span class="p">))</span></code></pre></figure>

<p>Cada <code class="language-plaintext highlighter-rouge">ret</code> en este caso solo existe dentro del lambda <em>(todo lo que esté entre <code class="language-plaintext highlighter-rouge">(\</code> y <code class="language-plaintext highlighter-rouge">)</code>)</em></p>

<p>Muchas veces se ven las monadas con el <a href="https://es.wikipedia.org/wiki/Az%C3%BAcar_sint%C3%A1ctico"><em>azúcar sintáctico</em></a> de la notación <code class="language-plaintext highlighter-rouge">do</code>, que lo hace muy conveniente porque nos deja, como en un paradigma imperativo, escribir una línea debajo de la otra.</p>

<h3 id="monadas-cont">Monadas Cont.</h3>
<p>Otra gran razón para implementar una secuencia de operaciones, es que estas puedan fallar. El fallo en cualquier renglón invalide toda la computación. Pensemos en métodos que podrían lanzar excepciones.
Para esto también existe una monada! Y podríamos escribir algo como:</p>

<figure class="highlight"><pre><code class="language-swift" data-lang="swift"><span class="kd">func</span> <span class="nf">precio</span><span class="p">(</span><span class="n">itemConNombre</span> <span class="nv">nombre</span><span class="p">:</span> <span class="kt">String</span><span class="p">)</span> <span class="k">throws</span> <span class="p">{</span>
        <span class="k">guard</span> <span class="k">let</span> <span class="nv">item</span> <span class="o">=</span> <span class="n">inventario</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="k">else</span> <span class="p">{</span>
            <span class="k">throw</span> <span class="kt">Errores</span><span class="o">.</span><span class="nf">noExiste</span><span class="p">(</span><span class="nv">nombre</span><span class="p">:</span> <span class="n">nombre</span><span class="p">)</span>
        <span class="p">}</span>

        <span class="k">guard</span> <span class="n">item</span><span class="o">.</span><span class="n">cantidad</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="k">else</span> <span class="p">{</span>
            <span class="k">throw</span> <span class="kt">Errores</span><span class="o">.</span><span class="n">fueraDeStock</span>
        <span class="p">}</span>

        <span class="n">item</span><span class="o">.</span><span class="n">price</span>
<span class="p">}</span></code></pre></figure>

<p>De esta forma</p>

<figure class="highlight"><pre><code class="language-haskell" data-lang="haskell"><span class="kr">data</span> <span class="kt">Errores</span> <span class="o">=</span> <span class="kt">FueraDeStock</span> <span class="o">|</span> <span class="kt">NoExiste</span> <span class="kt">String</span>

<span class="n">buscar</span> <span class="o">::</span> <span class="kt">Inventario</span> <span class="o">-&gt;</span> <span class="kt">String</span> <span class="o">-&gt;</span> <span class="kt">Maybe</span> <span class="kt">Item</span>
<span class="n">buscar</span> <span class="o">=</span> <span class="p">(</span><span class="o">...</span><span class="p">)</span>

<span class="n">precio</span> <span class="o">::</span> <span class="kt">String</span> <span class="o">-&gt;</span> <span class="kt">Either</span> <span class="kt">Errores</span> <span class="kt">Int</span>
<span class="n">precio</span> <span class="n">nombre</span> <span class="o">=</span> <span class="kr">do</span>
    <span class="n">item</span> <span class="o">&lt;-</span> <span class="n">maybe</span> <span class="p">(</span><span class="kt">Left</span> <span class="p">(</span><span class="kt">NoExiste</span> <span class="n">nombre</span><span class="p">))</span> <span class="kt">Right</span> <span class="n">itemEncontrado</span> <span class="c1">-- (1)
</span>
    <span class="n">when</span> <span class="p">(</span><span class="n">cantidad</span> <span class="n">item</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">(</span><span class="kt">Left</span> <span class="kt">FueraDeStock</span><span class="p">)</span>
    <span class="n">return</span> <span class="n">precio</span> <span class="n">item</span>
  <span class="kr">where</span>
    <span class="n">itemEncontrado</span> <span class="o">::</span> <span class="kt">Maybe</span> <span class="kt">Item</span>
    <span class="n">itemEncontrado</span> <span class="o">=</span> <span class="n">buscar</span> <span class="n">inventario</span> <span class="n">nombre</span></code></pre></figure>

<p>La idea de la función <a href="https://hackage.haskell.org/package/base-4.14.0.0/docs/Prelude.html#v:maybe"><code class="language-plaintext highlighter-rouge">maybe</code></a> es poder extraer el valor de un <code class="language-plaintext highlighter-rouge">Maybe</code> (algo que puede o no estar). En el caso de que pueda fallar, <em>devolveremos</em> un <code class="language-plaintext highlighter-rouge">Left</code> (recordemos, representaría como lanzar una excepción), y en el caso que hubiese un <code class="language-plaintext highlighter-rouge">Item</code>, devolveremos un <code class="language-plaintext highlighter-rouge">Right</code>.</p>

<p>De esta forma, no <em>ejecutaremos</em> el <code class="language-plaintext highlighter-rouge">return</code> hasta que no pasen las dos condiciones anteriores.</p>

<h2 id="getter-y-setter">Getter y Setter</h2>

<p>Por último, quiero tocar algo de modelado, y la parte de lo que menos quiero escribir, porque es la que más se separa del paradigma; pero no obstante puedo ver cómo alguien puede estar tentado a utilizar herramientas de modelado de paradigmas que ya conoce, y pensar en un <a href="http://aprendehaskell.es/content/ClasesDeTipos.html"><em>record</em></a> es parecido a un objeto. Pero si así fuera… donde ponemos los métodos de este objeto?! (Sin entrar en el mundo de <a href="https://hackage.haskell.org/package/lens"><code class="language-plaintext highlighter-rouge">lens</code></a>).
No voy a objetar (🤭) porque se que yo lo hice durante mucho tiempo, así que mientras que sepamos que hay <em>tela para cortar</em>, por ahora puedo vivir con que pensemos que son objetos.</p>

<figure class="highlight"><pre><code class="language-csharp" data-lang="csharp"><span class="k">class</span> <span class="nc">Point</span>
<span class="p">{</span>
    <span class="k">public</span> <span class="kt">int</span> <span class="n">edad</span><span class="p">;</span>
<span class="p">}</span></code></pre></figure>

<p>podríamos escribirlo así:</p>

<figure class="highlight"><pre><code class="language-haskell" data-lang="haskell"><span class="kr">data</span> <span class="kt">Persona</span> <span class="o">=</span> <span class="kt">Persona</span> <span class="p">{</span> <span class="n">edad</span> <span class="o">::</span> <span class="kt">Int</span> <span class="p">}</span></code></pre></figure>

<p>Y tendremos <em>gratis</em> la función <code class="language-plaintext highlighter-rouge">edad :: Persona -&gt; Int</code> que “saca” la edad de una persona. Cual un getter, y la construcción:</p>

<figure class="highlight"><pre><code class="language-haskell" data-lang="haskell"><span class="n">cambiarEdad</span> <span class="o">::</span> <span class="kt">Int</span> <span class="o">-&gt;</span> <span class="kt">Persona</span> <span class="o">-&gt;</span> <span class="kt">Persona</span>
<span class="n">cambiarEdad</span> <span class="n">nuevaEdad</span> <span class="n">persona</span> <span class="o">=</span> <span class="n">persona</span> <span class="p">{</span> <span class="n">edad</span> <span class="o">=</span> <span class="n">nuevaEdad</span> <span class="p">}</span></code></pre></figure>

<p>Como un setter. Pero, como en OOP no estamos limitados a simplemente asignar el nuevo valor; podríamos hacer lo que queramos!</p>

<figure class="highlight"><pre><code class="language-haskell" data-lang="haskell"><span class="n">cambiarEdad</span> <span class="o">::</span> <span class="kt">Int</span> <span class="o">-&gt;</span> <span class="kt">Persona</span> <span class="o">-&gt;</span> <span class="kt">Persona</span>
<span class="n">cambiarEdad</span> <span class="n">nuevaEdad</span> <span class="n">persona</span> <span class="o">=</span> <span class="n">persona</span> <span class="p">{</span> <span class="n">edad</span> <span class="o">=</span> <span class="n">nuevaEdad</span> <span class="o">+</span> <span class="mi">3</span> <span class="p">}</span></code></pre></figure>

<p>Podemos encontrar un patrón recurrente, donde tengamos funciones que <em>terminen</em> con el tipo: <code class="language-plaintext highlighter-rouge">foo :: … -&gt; Algo -&gt; Algo</code>. Si recordamos el ejemplo de <code class="language-plaintext highlighter-rouge">tarjetaValida</code>, todas las funciones intermedias que teníamos eran del tipo: <code class="language-plaintext highlighter-rouge">:: Int -&gt; Int</code>, y el ejercicio al lector hubiera generado una función con el tipo: <code class="language-plaintext highlighter-rouge">:: Char -&gt; Int -&gt; Int</code>. Podemos pensar en toda esta familia de funciones como funciones que “alteran”. Además ahora ya sabemos cómo combinarlas!
Por ejemplo, concatenar listas  <a href="https://hackage.haskell.org/package/base-4.14.0.0/docs/GHC-List.html#v:-43--43-"><code class="language-plaintext highlighter-rouge">(++) :: [a] -&gt; [a] -&gt; [a] </code></a> en donde toma una primera lista y una segunda, y las “altera” (recordando que en realidad lo que hace es <em>devolver</em> una nueva lista) o tomar los primeros <code class="language-plaintext highlighter-rouge">n</code> elementos (<a href="https://hackage.haskell.org/package/base-4.14.0.0/docs/GHC-List.html#v:take"><code class="language-plaintext highlighter-rouge">take :: Int -&gt; [a] -&gt; [a]</code></a>). Hay muchísimas funciones como estas, y probablemente escribamos tantas de estas como “métodos” podrían tener nuestros objetos, si lo modelamos en OOP.</p>

<figure class="highlight"><pre><code class="language-kotlin" data-lang="kotlin"><span class="kd">class</span> <span class="nc">Persona</span><span class="p">(</span><span class="kd">var</span> <span class="py">edad</span><span class="p">:</span> <span class="nc">Int</span><span class="p">,</span> <span class="kd">var</span> <span class="py">altura</span><span class="p">:</span> <span class="nc">Int</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">fun</span> <span class="nf">crecer</span><span class="p">(</span><span class="n">años</span> <span class="p">:</span> <span class="nc">Int</span><span class="p">)</span> <span class="p">{</span>
                 <span class="k">this</span><span class="p">.</span><span class="n">edad</span> <span class="p">+=</span> <span class="n">años</span>
                 <span class="k">this</span><span class="p">.</span><span class="n">altura</span> <span class="p">+=</span> <span class="n">años</span><span class="p">*</span><span class="mi">2</span>
    <span class="p">}</span>
<span class="p">}</span></code></pre></figure>

<figure class="highlight"><pre><code class="language-haskell" data-lang="haskell"><span class="kr">data</span> <span class="kt">Persona</span> <span class="o">=</span> <span class="kt">Persona</span> <span class="p">{</span> <span class="n">edad</span> <span class="o">::</span> <span class="kt">Int</span><span class="p">,</span> <span class="n">altura</span> <span class="o">::</span> <span class="kt">Int</span> <span class="p">}</span>

<span class="n">crecer</span> <span class="o">::</span> <span class="kt">Int</span> <span class="o">-&gt;</span> <span class="kt">Persona</span> <span class="o">-&gt;</span> <span class="kt">Persona</span>
<span class="n">crecer</span> <span class="n">a</span><span class="err">ñ</span><span class="n">os</span> <span class="n">persona</span> <span class="o">=</span> <span class="kt">Persona</span> <span class="p">{</span> <span class="n">edad</span> <span class="o">=</span> <span class="n">edad</span> <span class="n">persona</span> <span class="o">+</span> <span class="n">a</span><span class="err">ñ</span><span class="n">os</span><span class="p">,</span>  <span class="n">altura</span> <span class="o">=</span> <span class="n">altura</span> <span class="n">persona</span> <span class="o">+</span> <span class="p">(</span><span class="n">a</span><span class="err">ñ</span><span class="n">os</span> <span class="o">*</span> <span class="mi">2</span><span class="p">)</span> <span class="p">}</span></code></pre></figure>

<h2 id="fin">Fin</h2>
<p>Espero que con estas herramientas, el prospecto de programar en Haskell sea menos aterrorizador.</p>

</article>







<div class="separator">
  <img alt="Melian" src="/assets/cat-0fe72554239fb5bc68cc3b08063d5fb3d3984c6381e560b01fa8d5e35ed5a68e4741595a4929859029f18386c321ac391d55cccf60a51f08dd3148d38b5a44b7.png">
</div>


  <h3 class="related-post-title">Related Posts</h3>
  
  
  
    
    

    

    

  
    
    

    

    
      
      <div class="post ml2 related">
        <a href="/xpost/2021/04/15/discoverying-crystal/" class="post-link">
          <h4 class="post-title">Discovering Crystal</h4>
        </a>
        <p class="post-summary">
          
          <span class="related-categories">
            <a href="/categories#xpost">#xpost</a>
          </span>
        </p>
      </div>
      
      
    

  
    
    

    

    
      
      <div class="post ml2 related">
        <a href="/xpost/2021/01/31/inspiraciones/" class="post-link">
          <h4 class="post-title">Inspiraciones</h4>
        </a>
        <p class="post-summary">
          ¿Te pasa de querer programar algo y no saber que? tengo un bloqueo de ideas hace tiempo, quiero hacer algo con xxx y no se me ocurre qué hacer.
          <span class="related-categories">
            <a href="/categories#xpost">#xpost</a>
          </span>
        </p>
      </div>
      
      
    

  
    
    

    

    

  
    
    

    

    
      
      <div class="post ml2 related">
        <a href="/xpost/2020/09/14/koncierge-una-libreria-para-segmentar-usuarios/" class="post-link">
          <h4 class="post-title">koncierge Una librería para segmentar usuarios</h4>
        </a>
        <p class="post-summary">
          La historia de una librería para evaluar variantes de tests AB, dado una definición de un experimento con un DSL parecido a Mongo y un contexto.
          <span class="related-categories">
            <a href="/categories#xpost">#xpost</a>
          </span>
        </p>
      </div>
      
      
        
  



      </div>
    </div>
  </div>

  <footer class="center">
  <div class="measure">
    <small>
      Theme heavily inspired in <a href="http://johnotander.com">John Otander</a>' <a href="https://github.com/johno/pixyll">pixyll</a>.
    </small>
  </div>
</footer>
<!-- AnchorJS -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/anchor-js/4.2.0/anchor.min.js"></script>
<script>
    anchors.options.visible = 'touch';
    anchors.add('article h2, article h3, article h4, article h5, article h6');
</script>

</body>
</html>
